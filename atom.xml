<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>CassieLee.Blog</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://cassielee.top/"/>
  <updated>2020-03-16T07:01:37.169Z</updated>
  <id>https://cassielee.top/</id>
  
  <author>
    <name>CassieLee</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>JS</title>
    <link href="https://cassielee.top/2019/07/25/JS%E6%80%BB%E7%BB%93/"/>
    <id>https://cassielee.top/2019/07/25/JS总结/</id>
    <published>2019-07-25T08:08:50.000Z</published>
    <updated>2020-03-16T07:01:37.169Z</updated>
    
    <content type="html"><![CDATA[<pre><code>根据日常总结的知识点进行分析</code></pre><a id="more"></a><hr><h2 id="调用-new-的-4-件事"><a href="#调用-new-的-4-件事" class="headerlink" title="调用 new 的 4 件事"></a>调用 new 的 4 件事</h2><ul><li>创建一个新对象</li><li>将对象里面的 this 指向这个新的对象</li><li>将新对象连接到构造函数的原型</li><li>返回这个对象</li></ul><h2 id="闭包"><a href="#闭包" class="headerlink" title="闭包"></a>闭包</h2><p>函数 A 内部有一个函数 B，函数 B 可以访问带函数 A 中的变量，那么函数 B 就是闭包</p><p>私有变量</p><p>案例：沙箱</p>]]></content>
    
    <summary type="html">
    
      &lt;pre&gt;&lt;code&gt;根据日常总结的知识点进行分析&lt;/code&gt;&lt;/pre&gt;
    
    </summary>
    
      <category term="JS" scheme="https://cassielee.top/categories/JS/"/>
    
    
      <category term="JS" scheme="https://cassielee.top/tags/JS/"/>
    
  </entry>
  
  <entry>
    <title>Vue面试题总结</title>
    <link href="https://cassielee.top/2019/07/19/%E9%9D%A2%E8%AF%95%E9%A2%98%20-%20Vue/"/>
    <id>https://cassielee.top/2019/07/19/面试题 - Vue/</id>
    <published>2019-07-19T12:10:02.000Z</published>
    <updated>2019-08-05T02:13:37.035Z</updated>
    
    <content type="html"><![CDATA[<pre><code>Vue面试题</code></pre><a id="more"></a><h2 id="v-if-和-v-show-区别"><a href="#v-if-和-v-show-区别" class="headerlink" title="v-if 和 v-show 区别"></a>v-if 和 v-show 区别</h2><p><code>v-show</code>指令仅仅控制元素的显示方式，将<code>display:none</code>属性在 block 和 none 来回切换<br><code>v-if</code>指令会控制这个 DOM 节点的存在与否<br>当我们需要经常切换某个元素的显示/隐藏时，使用 v-show 会更加节省性能;当只需要一次显示或隐藏时，使用 v-if</p><hr><h2 id="Vue-的数据双向绑定原理"><a href="#Vue-的数据双向绑定原理" class="headerlink" title="Vue 的数据双向绑定原理"></a>Vue 的数据双向绑定原理</h2><p>采用<strong>数据劫持结合发布者-订阅者模式</strong>的方式，通过 Object.defineProperty()来劫持各个属性的 setter，getter,在数据变动时发布消息给订阅者，触发响应的监听回调。</p><hr><h2 id="Vue-组件间是怎么通讯的"><a href="#Vue-组件间是怎么通讯的" class="headerlink" title="Vue 组件间是怎么通讯的"></a>Vue 组件间是怎么通讯的</h2><hr><h2 id="常见指令"><a href="#常见指令" class="headerlink" title="常见指令"></a>常见指令</h2><hr><h2 id="怎么定义组件"><a href="#怎么定义组件" class="headerlink" title="怎么定义组件"></a>怎么定义组件</h2><hr><h2 id="Vue-路由是怎么做的（路由的原理）"><a href="#Vue-路由是怎么做的（路由的原理）" class="headerlink" title="Vue 路由是怎么做的（路由的原理）"></a>Vue 路由是怎么做的（路由的原理）</h2><hr><h2 id="怎么请求数据"><a href="#怎么请求数据" class="headerlink" title="怎么请求数据"></a>怎么请求数据</h2><hr><h2 id="谈谈组件化和模块化的区别、"><a href="#谈谈组件化和模块化的区别、" class="headerlink" title="谈谈组件化和模块化的区别、"></a>谈谈组件化和模块化的区别、</h2><p><code>模块化</code>：是从代码逻辑的角度进行划分的，方便代码分层开发，保证每个功能模块的职能单一<br><code>组件化</code>：是从 UI 的角度进行划分的，前端的组件化，方便 UI 组件的复用</p><hr><h2 id="Vue-全家桶"><a href="#Vue-全家桶" class="headerlink" title="Vue 全家桶"></a>Vue 全家桶</h2><hr><h2 id="Vuex-的使用和五个核心"><a href="#Vuex-的使用和五个核心" class="headerlink" title="Vuex 的使用和五个核心"></a>Vuex 的使用和五个核心</h2>]]></content>
    
    <summary type="html">
    
      &lt;pre&gt;&lt;code&gt;Vue面试题&lt;/code&gt;&lt;/pre&gt;
    
    </summary>
    
      <category term="面试题" scheme="https://cassielee.top/categories/%E9%9D%A2%E8%AF%95%E9%A2%98/"/>
    
    
      <category term="面试题" scheme="https://cassielee.top/tags/%E9%9D%A2%E8%AF%95%E9%A2%98/"/>
    
  </entry>
  
  <entry>
    <title>面试题总结</title>
    <link href="https://cassielee.top/2019/07/19/%E9%9D%A2%E8%AF%95%E9%A2%98/"/>
    <id>https://cassielee.top/2019/07/19/面试题/</id>
    <published>2019-07-19T12:10:02.000Z</published>
    <updated>2019-08-05T01:40:00.862Z</updated>
    
    <content type="html"><![CDATA[<pre><code>根据日常总结的知识点进行分析</code></pre><a id="more"></a><hr><h2 id="写-React-Vue-项目时为什么要在列表组件中写-key，其作用是什么"><a href="#写-React-Vue-项目时为什么要在列表组件中写-key，其作用是什么" class="headerlink" title="写 React / Vue 项目时为什么要在列表组件中写 key，其作用是什么"></a>写 React / Vue 项目时为什么要在列表组件中写 key，其作用是什么</h2><p>解析：（Vue/React）key 的作用是为了在 diff 算法执行时更快的找到对应的节点，提高 diff 速度</p><p>(Vue)key 的作用是为了在数据变化时强制更新组件，以避免“原地复用”带来的副作用。</p><hr><h2 id="从用户刷新网页开始，一次-js-请求一般情况下有哪些地方会有缓存处理"><a href="#从用户刷新网页开始，一次-js-请求一般情况下有哪些地方会有缓存处理" class="headerlink" title="从用户刷新网页开始，一次 js 请求一般情况下有哪些地方会有缓存处理"></a>从用户刷新网页开始，一次 js 请求一般情况下有哪些地方会有缓存处理</h2><p>解析：DNS 缓存、CDN 缓存、浏览器缓存、服务器缓存</p><h3 id="DNS-缓存-即-（Domain-Name-System-域名系统）"><a href="#DNS-缓存-即-（Domain-Name-System-域名系统）" class="headerlink" title="DNS 缓存 即 （Domain Name System 域名系统）"></a>DNS 缓存 即 （Domain Name System 域名系统）</h3><p>为了增加访问效率， 计算机有域名缓存机制。即当访问过某个网站并得到其 IP 后，会将其域名和 IP 缓存下来， 下一次访问的时候，就不需要再请求域名服务器获取 IP, 直接使用缓存中的 IP，提高了响应的速度。 当前缓存时间是有有效时间的，当过了有效时间后， 还是需要先请求域名解析。</p><p>扩： DNS 预解析</p><p>因为在调用当前页面所在域名外的域名文件时，会遇到请求延时非常严重的情况。<br>我们可以使用 DNS 预解析。</p><ol><li>用 meta 信息来告知浏览器，当前页面要做 DNS 预解析：</li></ol><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;meta http-equiv=<span class="string">"x-dns-prefetch-control"</span> content=<span class="string">"on"</span> /&gt;</span><br></pre></td></tr></table></figure><p>在页面 header 中使用 link 标签来强制对 DNS 预解析</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">link</span> <span class="attr">rel</span>=<span class="string">"dns-prefetch"</span> <span class="attr">href</span>=<span class="string">"http://bdimg.share.baidu.com"</span> /&gt;</span></span><br></pre></td></tr></table></figure><h3 id="CDN-即-（Content-Delivery-NetWork）-内容分发网络"><a href="#CDN-即-（Content-Delivery-NetWork）-内容分发网络" class="headerlink" title="CDN 即 （Content Delivery NetWork） 内容分发网络"></a>CDN 即 （Content Delivery NetWork） 内容分发网络</h3><p>CDN 是构建在网络之上的内容分发网络，依靠部署在各地的边缘服务器，通过中心平台的负载均衡、内容分发、调度等功能模块，使用户就近获取所需内容，降低网络拥塞，提高用户访问响应速度和命中率。CDN 的关键技术主要有内容存储和分发技术。</p><p>通俗解释：就是当我们发送一个 web 请求时，会先经过它一道手，然后它帮我们计算路径，去哪得到这些东东（representations）的路径短且快。这个是网站管理员部署的，所以他们也可以将大家经常访问的 representations 放在 CDN 里，这样，就响应就更快了。</p><h3 id="浏览器缓存"><a href="#浏览器缓存" class="headerlink" title="浏览器缓存"></a>浏览器缓存</h3><p>通过浏览器实现 HTTP 缓存。</p><p>Expires<br>添加 Expires 头能有效的利用浏览器的缓存能力来改善页面的性能，能在后续的页面中有效避免很多不必要的 Http 请求，WEB 服务器使用 Expires 头来告诉 Web 客户端它可以使用一个组件的当前副本，直到指定的时间为止。</p><p>例如：Expires：Thu，15 Apr 2010 20：00：00 GMT; 他告诉浏览器缓存有效性持续到 2010 年 4 月 15 日为止，在这个时间之内相同的请求使用缓存，这个时间之外使用 http 请求。</p><p>Cathe-Control<br>使用 max-age 指定组件被缓存多久，从请求开始在 max-age 时间内浏览器使用缓存，之外的使用请求，这样就可以消除 Expires 的限制.</p><p>例如：Cathe-Control：max-age=315360000</p><h3 id="服务器缓存"><a href="#服务器缓存" class="headerlink" title="服务器缓存"></a>服务器缓存</h3><p>服务器缓存一般指缓存服务器<br>缓存指的是将需要频繁访问的网络内容存放在离用户较近、访问速度更快的系统中，以提高内容访问速度的一种技术。缓存服务器就是存放频繁访问内容的服务器。</p><hr><h2 id="Javascript：history-go-和-history-back-的用法与区别"><a href="#Javascript：history-go-和-history-back-的用法与区别" class="headerlink" title="Javascript：history.go()和 history.back()的用法与区别"></a>Javascript：history.go()和 history.back()的用法与区别</h2><p>go() 方法可加载历史列表中的某个具体的页面。<br>该参数可以是数字，使用的是要访问的 URL 在 History 的 URL 列表中的相对位置。（-1 上一个页面，1 前进一个页面)。或一个字符串，字符串必须是局部或完整的 URL，该函数会去匹配字符串的第一个 URL。</p><p>go(-1):返回上一页，原页面表单中的内容会丢失；<br>back():返回上一页，原页表表单中的内容会保留。</p><hr><h2 id="什么是防抖和节流？有什么区别？如何实现"><a href="#什么是防抖和节流？有什么区别？如何实现" class="headerlink" title="什么是防抖和节流？有什么区别？如何实现"></a>什么是防抖和节流？有什么区别？如何实现</h2><p>防抖(debounce)<br>触发高频事件后 n 秒内函数只会执行一次，如果 n 秒内高频事件再次被触发，则重新计算时间(函数防抖: 任务频繁触发的情况下，只有任务触发的间隔超过指定间隔的时候，任务才会执行。)</p><p>思路：<br>每次触发事件时都取消之前的延时调用方法</p><p>其实函数防抖的原理也非常地简单，通过闭包保存一个标记来保存 setTimeout 返回的值，每当用户输入的时候把前一个 setTimeout clear 掉，然后又创建一个新的 setTimeout，这样就能保证输入字符后的 interval 间隔内如果还有字符输入的话，就不会执行 fn 函数了。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">debounce</span>(<span class="params">fn</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> timeout = <span class="literal">null</span> <span class="comment">// 创建一个标记用来存放定时器的返回值</span></span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    clearTimeout(timeout) <span class="comment">// 每当用户输入的时候把前一个 setTimeout clear 掉</span></span><br><span class="line">    timeout = setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">      <span class="comment">// 然后又创建一个新的 setTimeout, 这样就能保证输入字符后的 interval 间隔内如果还有字符输入的话，就不会执行 fn 函数</span></span><br><span class="line">      fn.apply(<span class="keyword">this</span>, <span class="built_in">arguments</span>)</span><br><span class="line">    &#125;, <span class="number">500</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">sayHi</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'防抖成功'</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> inp = <span class="built_in">document</span>.getElementById(<span class="string">'inp'</span>)</span><br><span class="line">inp.addEventListener(<span class="string">'input'</span>, debounce(sayHi)) <span class="comment">// 防抖</span></span><br></pre></td></tr></table></figure><p>节流(throttle)<br>高频事件触发，但在 n 秒内只会执行一次，所以节流会稀释函数的执行频率(函数节流: 指定时间间隔内只会执行一次任务)</p><p>思路：<br>每次触发事件时都判断当前是否有等待执行的延时函数</p><p>简单来说，函数的节流就是通过闭包保存一个标记（canRun = true），在函数的开头判断这个标记是否为 true，如果为 true 的话就继续执行函数，否则则 return 掉，判断完标记后立即把这个标记设为 false，然后把外部传入的函数的执行包在一个 setTimeout 中，最后在 setTimeout 执行完毕后再把标记设置为 true（这里很关键），表示可以执行下一次的循环了。当 setTimeout 还未执行的时候，canRun 这个标记始终为 false，在开头的判断中被 return 掉</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">throttle</span>(<span class="params">fn</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> canRun = <span class="literal">true</span> <span class="comment">// 通过闭包保存一个标记</span></span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!canRun) <span class="keyword">return</span> <span class="comment">// 在函数开头判断标记是否为true，不为true则return</span></span><br><span class="line">    canRun = <span class="literal">false</span> <span class="comment">// 立即设置为false</span></span><br><span class="line">    setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">      <span class="comment">// 将外部传入的函数的执行放在setTimeout中</span></span><br><span class="line">      fn.apply(<span class="keyword">this</span>, <span class="built_in">arguments</span>)</span><br><span class="line">      <span class="comment">// 最后在setTimeout执行完毕后再把标记设置为true(关键)表示可以执行下一次循环了。当定时器没有执行的时候标记永远是false，在开头被return掉</span></span><br><span class="line">      canRun = <span class="literal">true</span></span><br><span class="line">    &#125;, <span class="number">500</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">sayHi</span>(<span class="params">e</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(e.target.innerWidth, e.target.innerHeight)</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">window</span>.addEventListener(<span class="string">'resize'</span>, throttle(sayHi))</span><br></pre></td></tr></table></figure><p>总结：其实函数节流与函数防抖的原理非常简单，巧妙地使用 setTimeout 来存放待执行的函数，这样可以很方便的利用 clearTimeout 在合适的时机来清除待执行的函数。<br>使用函数节流与函数防抖的目的，在开头的栗子中应该也能看得出来，就是为了节约计算机资源。</p><hr>]]></content>
    
    <summary type="html">
    
      &lt;pre&gt;&lt;code&gt;根据日常总结的知识点进行分析&lt;/code&gt;&lt;/pre&gt;
    
    </summary>
    
      <category term="面试题" scheme="https://cassielee.top/categories/%E9%9D%A2%E8%AF%95%E9%A2%98/"/>
    
    
      <category term="面试题" scheme="https://cassielee.top/tags/%E9%9D%A2%E8%AF%95%E9%A2%98/"/>
    
  </entry>
  
  <entry>
    <title>js 的继承机制</title>
    <link href="https://cassielee.top/2019/01/19/js%E7%BB%A7%E6%89%BF%E6%9C%BA%E5%88%B6/"/>
    <id>https://cassielee.top/2019/01/19/js继承机制/</id>
    <published>2019-01-19T11:10:02.000Z</published>
    <updated>2020-03-16T06:55:47.161Z</updated>
    
    <content type="html"><![CDATA[<h1 id="js-的继承机制"><a href="#js-的继承机制" class="headerlink" title="js 的继承机制"></a>js 的继承机制</h1><a id="more"></a><h2 id="ES5-和-ES6-及继承机制"><a href="#ES5-和-ES6-及继承机制" class="headerlink" title="ES5 和 ES6 及继承机制"></a>ES5 和 ES6 及继承机制</h2><h2 id="ES5-继承机制"><a href="#ES5-继承机制" class="headerlink" title="ES5 继承机制"></a>ES5 继承机制</h2><p>在 js 万物皆对象，但事还是区分普通对象和函数对象，只有函数对象才有 <code>prototype</code> 属性，但所有对象都有<code>__proto__</code>属性</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">A</span>(<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line"><span class="keyword">var</span> B = <span class="keyword">new</span> A()</span><br></pre></td></tr></table></figure><p>那这里就得出几个公式：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">B.**proto**== A.prototype;</span><br><span class="line">B.constructor == A;</span><br><span class="line">a.prototype.constuctor = A;</span><br></pre></td></tr></table></figure><p>那这是实现继承的基础； 也就是说 A.prototype 是 A 的原型对象，A 是构造函数，B 是 A 的实例，原型对象（A.prototype）是 构造函数（A）的一个实例。而此时 this 指向是指向实例。 明白这个关系实现继承就很简单了！看一下下面的代码</p><h3 id="原型链继承"><a href="#原型链继承" class="headerlink" title="原型链继承"></a>原型链继承</h3><p>通过重写子类的原型 等于 父类的一个实例，（父类的实例属相变成子类的原型属性）</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">father</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.faName = <span class="string">'father'</span></span><br><span class="line">&#125;</span><br><span class="line">father.prototype.getfaName = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="keyword">this</span>.faName)</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">child</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.chName = <span class="string">'child'</span></span><br><span class="line">&#125;</span><br><span class="line">child.prototype = <span class="keyword">new</span> father()</span><br><span class="line">child.prototype.constructor = child</span><br><span class="line">child.prototype.getchName = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="keyword">this</span>.chName)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="组合继承-（比较常用，也有缺点）"><a href="#组合继承-（比较常用，也有缺点）" class="headerlink" title="组合继承 （比较常用，也有缺点）"></a>组合继承 （比较常用，也有缺点）</h3><p>通过子类的原型对象指向父类实例的方式来实现继承，那我们不难发现原型链的形成是真正是靠<code>__proto__</code> 而非 prototype，子类的实例可以访问父类原型上的方法，是因为子类实例通过<code>__proto__</code>与父类的原型对象有连接</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//先来个父类，带些属性</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Super</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.flag = <span class="literal">true</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//为了提高复用性，方法绑定在父类原型属性上</span></span><br><span class="line">Super.prototype.getFlag = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">this</span>.flag</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//来个子类</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Sub</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.subFlag = <span class="literal">false</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//实现继承</span></span><br><span class="line">Sub.prototype = <span class="keyword">new</span> Super()</span><br><span class="line"><span class="comment">//给子类添加子类特有的方法，注意顺序要在继承之后</span></span><br><span class="line">Sub.prototype.getSubFlag = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">this</span>.subFlag</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//构造实例</span></span><br><span class="line"><span class="keyword">var</span> es5 = <span class="keyword">new</span> Sub()</span><br></pre></td></tr></table></figure><h3 id="寄生组合继承-（业内比较提倡的方法）"><a href="#寄生组合继承-（业内比较提倡的方法）" class="headerlink" title="寄生组合继承 （业内比较提倡的方法）"></a>寄生组合继承 （业内比较提倡的方法）</h3><p>所谓寄生组合式继承，即通过借助构造函数来继承属性，通过原型链的混成形式来继承方法。 其背后的基本思路是：不必为了指定子类型的原型而调用超类型的构造函数，我们所需要的无非就是超类型原型的一个副本而已。本质上，就是使用寄生式继承来继承超类型的原型，然后再将结果指定给子类型的原型。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">inserit</span>(<span class="params">son, father</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> obj = <span class="built_in">Object</span>.create(father.prototype)</span><br><span class="line">  son.prototype = obj</span><br><span class="line">  obj.constructor = son</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">SuperType</span>(<span class="params">name, colors</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.name = name</span><br><span class="line">  <span class="keyword">this</span>.colors = colors</span><br><span class="line">&#125;</span><br><span class="line">SuperType.prototype.sayName = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">this</span>.name</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">SubType</span>(<span class="params">job, name, color</span>) </span>&#123;</span><br><span class="line">  SuperType.call(<span class="keyword">this</span>, name, color)</span><br><span class="line">  <span class="keyword">this</span>.job = job</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//核心方法</span></span><br><span class="line">inserit(SubType, SuperType)</span><br><span class="line">SubType.prototype.sayjob = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">this</span>.job</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> instance = <span class="keyword">new</span> SubType(<span class="string">'doctor'</span>, <span class="string">'John'</span>, [<span class="string">'red'</span>, <span class="string">'green'</span>])</span><br><span class="line"><span class="built_in">console</span>.log(instance.sayjob(), instance.sayName()) <span class="comment">//doctor,John</span></span><br></pre></td></tr></table></figure><p>[x] 原型链继承缺点：父类包含引用类型的属性，那么子类所有实例都会共享该属性（包含引用类型的原型属性会被实例共享），在创建子类实例时，不能向父类的构造函数传递参数<br>[x] 组合继承的缺点：两次调用父类构造函数：（第一次是在创建子类原型的时候，第二次是在子类构造函数内部）子类继承父类的属性，一组在子类实例上，一组在子类原型上（在子类原型上创建不必要的多余的属性）（实例上的屏蔽原型上的同名属性）效率低<br>[x] 组合继承的优点：只调用一次父类的构造函数,避免了在子类原型上创建不必要的，多余的属性，原型链保持不变<br>ES5 的继承机制总结<br>ES5 的继承机制简单来说就是：实质是先创造子类的实例对象 this，然后再将父类的方法添加到 this 上面（Parent.apply(this)）</p><h2 id="ES6-的继承机制"><a href="#ES6-的继承机制" class="headerlink" title="ES6 的继承机制"></a>ES6 的继承机制</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Point</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>(x) &#123;</span><br><span class="line">    <span class="keyword">this</span>.x = <span class="number">1</span></span><br><span class="line">    <span class="keyword">this</span>.p = <span class="number">2</span></span><br><span class="line">  &#125;</span><br><span class="line">  print() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.x</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">Point.prototype.z = <span class="string">'4'</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ColorPoint</span> <span class="keyword">extends</span> <span class="title">Point</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>(x) &#123;</span><br><span class="line">    <span class="keyword">this</span>.color = color <span class="comment">// ReferenceError</span></span><br><span class="line">    <span class="keyword">super</span>(x, y)</span><br><span class="line">    <span class="keyword">this</span>.x = x <span class="comment">// 正确</span></span><br><span class="line">  &#125;</span><br><span class="line">  m() &#123;</span><br><span class="line">    <span class="keyword">super</span>.print()</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>ES6 继承是通过 <strong>class</strong>、<strong>extends</strong> 关键字来实现继承 Point 是父类，ColorPoint 是子类 通过 class 新建子类 extends 继承父类的方式实现继承，方式比 ES5 简单的多。</p><h3 id="constructor-NaN"><a href="#constructor-NaN" class="headerlink" title="constructor"></a>constructor</h3><p>constructor 方法是类的构造函数，是一个默认方法，通过 new 命令创建对象实例时，自动调用该方法。一个类必须有 constructor 方法，如果没有显式定义，一个默认的 consructor 方法会被默认添加。所以即使你没有添加构造函数，也是会有一个默认的构造函数的。一般 constructor 方法返回实例对象 this ，但是也可以指定 constructor 方法返回一个全新的对象，让返回的实例对象不是该类的实例。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Points</span> </span>&#123;</span><br><span class="line"><span class="keyword">constructor</span>(x) &#123;</span><br><span class="line"><span class="keyword">this</span>.x = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">this</span>.p = <span class="number">2</span>;</span><br><span class="line">&#125;</span><br><span class="line">print() &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">this</span>.x;</span><br><span class="line">&#125;</span><br><span class="line">statc getname()&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">new</span>.target.name;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 等同于：</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Points</span>(<span class="params">x</span>) </span>&#123;</span><br><span class="line"><span class="keyword">this</span>.x = x;</span><br><span class="line"><span class="keyword">this</span>.p = <span class="number">2</span>;</span><br><span class="line">&#125;</span><br><span class="line">Points.prototype.print = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="string">'('</span> + <span class="keyword">this</span>.x +<span class="string">')'</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>也就是说 constructor 就代表在父类上加属性，而在 class 对象加方法属性 等于在原型上的加。而这些属性方法 只有通过 new 出的实例 或者是 extends 继承出来的实例才可以获取到 所以我们可以得到</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> Points().__proto__.print() <span class="comment">//可以调用到 Points 的 print 方法</span></span><br><span class="line"><span class="keyword">new</span> Points().x = <span class="number">1</span> <span class="comment">//可以调用到 constructor 里面的 this.x=1</span></span><br></pre></td></tr></table></figure><h3 id="super"><a href="#super" class="headerlink" title="super"></a>super</h3><p>super 既可以当做函数使用，也可以当做对象使用两种使用的时候完全不一样， 函数用时 : 在 constructor 中必须调用 super 方法，因为子类没有自己的 this 对象，而是继承父类的 this 对象，然后对其进行加工,而 super 就代表了父类的构造函数。super 虽然代表了父类 A 的构造函数，但是返回的是子类 B 的实例，即 super 内部的 this 指的是 B，因此 super() 在这里相当于</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">A.prototype.constructor.call(<span class="keyword">this</span>, props)</span><br></pre></td></tr></table></figure><p>在 super() 执行时，它指向的是 子类 B 的构造函数，而不是父类 A 的构造函数。也就是说，super() 内部的 this 指向的是 B。所以在第一个 es6 的例子中子类的 this 指向的是自己。、</p><p><strong>当做对象使用</strong> ： 在普通方法中，指向父类的原型对象；在静态方法中，指向父类。 所以在子类的方法中 super.print();指向的是父类原型上的方法。 <strong>但是因为 super 的两种用法，所以 es6 规定在使用必须要明确使用方式，像单独 console.log(super) 就会报错。</strong></p><h3 id="static"><a href="#static" class="headerlink" title="static"></a>static</h3><p>顾名思义是静态方法的意思，类相当于实例的原型， 所有在类中定义的方法， 都会被实例继承。 如果在一个方法前， 加上 static 关键字， 就表示该方法不会被实例继承， 而是直接通过类来调用， 这就称为“ 静态方法”。静态方法调用直接在类上进行，而在类的实例上不可被调用。静态方法通常用于创建 实用/工具 函数。</p><h3 id="new-target"><a href="#new-target" class="headerlink" title="new.target"></a>new.target</h3><p>new.target 属性允许你检测函数或构造方法是否通过是通过 new 运算符被调用的。在通过 new 运算符被初始化的函数或构造方法中，new.target 返回一个指向构造方法或函数的引用。在普通的函数调用中，new.target 的值是 undefined。</p><p>也就是说 new.target 的功能就是用来检测函数的调用是不是通过 new 去创建一个新对象的，而且 new.target 返回的是一个指向函数的引用，也就是说我们能够确定是哪个函数进行了 new 操作。</p><h2 id="ES6-的继承机制总结"><a href="#ES6-的继承机制总结" class="headerlink" title="ES6 的继承机制总结"></a>ES6 的继承机制总结</h2><p>先创建父类实例 this 通过 <strong>class</strong>、 <strong>extends</strong> 、<strong>super</strong> 关键字定义子类，并改变 this 指向,super 本身是指向父类的构造函数但做函数调用后返回的是子类的实例，实际上做了父类.prototype.constructor.call(this)，做对象调用时指向父类.prototype,从而实现继承。</p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;js-的继承机制&quot;&gt;&lt;a href=&quot;#js-的继承机制&quot; class=&quot;headerlink&quot; title=&quot;js 的继承机制&quot;&gt;&lt;/a&gt;js 的继承机制&lt;/h1&gt;
    
    </summary>
    
      <category term="面试题" scheme="https://cassielee.top/categories/%E9%9D%A2%E8%AF%95%E9%A2%98/"/>
    
    
      <category term="面试题" scheme="https://cassielee.top/tags/%E9%9D%A2%E8%AF%95%E9%A2%98/"/>
    
  </entry>
  
  <entry>
    <title>ES6面试题</title>
    <link href="https://cassielee.top/2018/01/19/ES6/"/>
    <id>https://cassielee.top/2018/01/19/ES6/</id>
    <published>2018-01-19T04:10:02.000Z</published>
    <updated>2019-08-05T01:38:07.738Z</updated>
    
    <content type="html"><![CDATA[<pre><code>ES6面试题</code></pre><a id="more"></a><h2 id="普通函数和箭头函数的区别"><a href="#普通函数和箭头函数的区别" class="headerlink" title="普通函数和箭头函数的区别"></a>普通函数和箭头函数的区别</h2><ul><li>箭头函数没有 prototype(原型)，所以箭头函数本身没有 this</li><li>箭头函数的 this 在定义的时候继承自外层第一个普通函数的 this。</li><li>如果箭头函数外层没有普通函数，严格模式和非严格模式下它的 this 都会指向 window(全局对象)</li><li>箭头函数本身的 this 指向不能改变，但可以修改它要继承的对象的 this。</li><li>箭头函数的 this 指向全局，使用 arguments 会报未声明的错误。</li><li>箭头函数的 this 指向普通函数时,它的 argumens 继承于该普通函数</li><li>使用 new 调用箭头函数会报错，因为箭头函数没有 constructor</li><li>箭头函数不支持 new.target</li><li>箭头函数不支持重命名函数参数,普通函数的函数参数支持重命名</li><li>箭头函数相对于普通函数语法更简洁优雅</li></ul><p>箭头函数的注意事项及不适用场景</p><ul><li>箭头函数的注意事项：</li><li>箭头函数一条语句返回对象字面量，需要加括号</li><li>箭头函数在参数和箭头之间不能换行</li><li>箭头函数的解析顺序相对||靠前</li></ul><p>不适用场景：箭头函数的 this 意外指向和代码的可读性。</p><hr><h2 id="Vue-的数据双向绑定原理"><a href="#Vue-的数据双向绑定原理" class="headerlink" title="Vue 的数据双向绑定原理"></a>Vue 的数据双向绑定原理</h2><hr>]]></content>
    
    <summary type="html">
    
      &lt;pre&gt;&lt;code&gt;ES6面试题&lt;/code&gt;&lt;/pre&gt;
    
    </summary>
    
      <category term="面试题" scheme="https://cassielee.top/categories/%E9%9D%A2%E8%AF%95%E9%A2%98/"/>
    
    
      <category term="面试题" scheme="https://cassielee.top/tags/%E9%9D%A2%E8%AF%95%E9%A2%98/"/>
    
  </entry>
  
  <entry>
    <title>hook学习</title>
    <link href="https://cassielee.top/2018/01/19/hook/"/>
    <id>https://cassielee.top/2018/01/19/hook/</id>
    <published>2018-01-19T04:10:02.000Z</published>
    <updated>2019-08-30T07:55:33.128Z</updated>
    
    <content type="html"><![CDATA[<pre><code>hook学习</code></pre><a id="more"></a>]]></content>
    
    <summary type="html">
    
      &lt;pre&gt;&lt;code&gt;hook学习&lt;/code&gt;&lt;/pre&gt;
    
    </summary>
    
      <category term="学习笔记" scheme="https://cassielee.top/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="学习笔记" scheme="https://cassielee.top/tags/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>React的基本使用</title>
    <link href="https://cassielee.top/2017/07/19/React%E7%9A%84%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8/"/>
    <id>https://cassielee.top/2017/07/19/React的基本使用/</id>
    <published>2017-07-19T12:52:02.000Z</published>
    <updated>2020-03-16T07:02:10.411Z</updated>
    
    <content type="html"><![CDATA[<h2 id="react-是什么"><a href="#react-是什么" class="headerlink" title="react 是什么"></a>react 是什么</h2><ul><li>React 是一个 JS 库，用来构建用户界面（写 HTML，构建 web 应用）</li><li>从 MVC 的角度来看，相当于 视图层 V（View） 的内容。</li></ul><h2 id="react-的特点"><a href="#react-的特点" class="headerlink" title="react 的特点"></a>react 的特点</h2><ul><li>声明式： 我们只需要描述页面长什么样子就可以了，React 负责更新页面</li><li>基于组件（组件化）</li><li>学习一次，随处使用（Web 、 安卓/ios、vr …）</li></ul><h2 id="React-的基本使用"><a href="#React-的基本使用" class="headerlink" title="React 的基本使用"></a>React 的基本使用</h2><ul><li><p>安装：npm i react react-dom</p></li><li><p>引入 react 和 react-dom 两个 js 文件（注意：引入顺序，react 在前，react-dom 在后）</p></li><li><p>创建 React 元素</p><ul><li><code>const h1 = React.createElement(&#39;h1&#39;, null, &#39;子节点&#39;)</code></li></ul></li><li><p>渲染创建好的 React 元素，到页面中</p><ul><li><code>ReactDOM.render(h1, document.getElementById(&#39;root&#39;))</code></li></ul></li></ul><h2 id="React-createElement-方法的说明"><a href="#React-createElement-方法的说明" class="headerlink" title="React.createElement() 方法的说明"></a>React.createElement() 方法的说明</h2><ul><li>作用：创建 react 元素的</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建React元素</span></span><br><span class="line"><span class="comment">// 第一个参数：表示要创建什么元素，就是 HTML 标签名称</span></span><br><span class="line"><span class="comment">// 第二个参数：表示元素自身属性，如果没有就传 null</span></span><br><span class="line"><span class="comment">//  如果要指定元素自身的属性，就传递一个对象（&#123;&#125;）</span></span><br><span class="line"><span class="comment">//  1 class ==&gt; className</span></span><br><span class="line"><span class="comment">//  2 for ==&gt; htmlFor</span></span><br><span class="line"><span class="comment">// 第三个及其以后的参数：表示元素的子节点（文本、元素节点）</span></span><br><span class="line"><span class="comment">//  如果是文本节点，就直接传递 字符串。</span></span><br><span class="line"><span class="comment">//  如果是元素节点，就继续调用 React.createElement() 方法，创建新的React元素节点</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// const h1 = React.createElement('div', null, 'Hello React')</span></span><br><span class="line"><span class="keyword">const</span> h1 = React.createElement(</span><br><span class="line">  <span class="string">'h1'</span>,</span><br><span class="line">  &#123;</span><br><span class="line">    id: <span class="string">'title'</span>,</span><br><span class="line">    className: <span class="string">'cls'</span>,</span><br><span class="line">    htmlFor: <span class="string">'d'</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="string">'Hello React'</span>,</span><br><span class="line">  <span class="string">'test 文本节点'</span>,</span><br><span class="line">  React.createElement(<span class="string">'span'</span>, <span class="literal">null</span>, <span class="string">'这是一个span'</span>)</span><br><span class="line">)</span><br></pre></td></tr></table></figure><h2 id="React-脚手架初始化项目的步骤"><a href="#React-脚手架初始化项目的步骤" class="headerlink" title="React 脚手架初始化项目的步骤"></a>React 脚手架初始化项目的步骤</h2><ul><li>命令：<code>npx create-react-app 项目名称</code><ul><li>比如：<code>npx create-react-app my-app</code></li></ul></li><li>npx 命令：简化使用脚手架初始化项目的流程<ul><li>不使用 npx：1 先全局安装脚手架的包 2 使用脚手架包提供的命令来初始化项目</li><li>使用 npx：不需要再全局安装脚手架的包，直接就可以初始化项目</li></ul></li><li>如何启动项目？进入项目根目录然后，执行以下命令<ul><li>yarn start</li><li>npm start</li></ul></li></ul><h2 id="在脚手架中使用-react"><a href="#在脚手架中使用-react" class="headerlink" title="在脚手架中使用 react"></a>在脚手架中使用 react</h2><ul><li>导入<ul><li><code>import React from &#39;react&#39;</code></li><li><code>import ReactDOM from &#39;react-dom&#39;</code></li></ul></li></ul><h2 id="JSX"><a href="#JSX" class="headerlink" title="JSX"></a>JSX</h2><ul><li>为什么要学习 JSX ？<ul><li>因为 createElement 形式，太繁琐，不直观，书写效率不高，所以，我们不想用这种方式。</li><li>JSX 特点：不反锁，直观，书写效率高</li></ul></li><li>JSX 是什么？ JavaScript XML（HTML），也就是在 JS 中书写 HTMl 格式的代码</li></ul><h2 id="JSX-的基本使用"><a href="#JSX-的基本使用" class="headerlink" title="JSX 的基本使用"></a>JSX 的基本使用</h2><ul><li><p>导入 react 和 react-dom</p></li><li><p>使用 JSX 语法创建 React 元素</p><ul><li>JSX 就跟写 HTML 一样</li></ul></li><li><p>渲染创建好的 React 元素</p></li></ul><h2 id="JSX-语法的注意点"><a href="#JSX-语法的注意点" class="headerlink" title="JSX 语法的注意点"></a>JSX 语法的注意点</h2><ul><li><p>JSX 元素的属性名推荐使用：驼峰命名法</p></li><li><p>class ===&gt; className</p></li><li><p>如果元素没有子节点，可以使用 单标签 方式来结束</p><ul><li>比如：<code>&lt;div /&gt;</code></li></ul></li><li><p>推荐使用 () 来包裹 JSX，从而避免 JS 中自动插入分号机制</p></li></ul><h2 id="在-JSX-中使用-JS-表达式（数据）"><a href="#在-JSX-中使用-JS-表达式（数据）" class="headerlink" title="在 JSX 中使用 JS 表达式（数据）"></a>在 JSX 中使用 JS 表达式（数据）</h2><ul><li>语法：使用 {} ，就可以在 JSX 中使用 JS 中的数据了<ul><li><code>&lt;div&gt;Hello {name + &#39;666&#39;}&lt;/div&gt;</code></li></ul></li><li>原则：可以在 {} 中使用任何的 JS 表达式。</li><li>注意：不能在 {} 中，使用 语句！<ul><li>比如： if/for/switch …</li></ul></li><li>注意：不能在 {} 中使用对象，除了 style 属性以外！！！</li><li>JSX 自身也是一个 JS 表达式，所以，可以在 {} 中继续使用 JSX ！！！</li></ul><h2 id="React-的条件渲染"><a href="#React-的条件渲染" class="headerlink" title="React 的条件渲染"></a>React 的条件渲染</h2><ul><li>使用 if/esle 来实现</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> loadData = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">if</span> (isLoading) &#123;</span><br><span class="line">    <span class="keyword">return</span> &lt;div&gt;loading...&lt;/div&gt;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> &lt;div&gt;加载完成后的列表结构&lt;/div&gt;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> h1 = &lt;div&gt;&#123;loadData()&#125;&lt;/div&gt;</span><br></pre></td></tr></table></figure><ul><li>使用三元表达式</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> loadData = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> isLoading ? &lt;div&gt;loading...&lt;/div&gt; : &lt;div&gt;加载完成后的列表结构&lt;/div&gt;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>逻辑运算符 &amp;&amp;</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> loadData = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> isLoading &amp;&amp; &lt;div&gt;loading...&lt;/div&gt;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="React-中的列表渲染"><a href="#React-中的列表渲染" class="headerlink" title="React 中的列表渲染"></a>React 中的列表渲染</h2><ul><li>使用数组的 map 方法来进行列表渲染</li><li>需要给被遍历生成的元素添加 key 属性，key 应该是唯一的。尽量避免使用 index 作为索引号。</li><li>剩下的就是 JS 中 map 方法的使用了。</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;ul&gt;</span><br><span class="line">  &#123;songs.map(<span class="function"><span class="params">item</span> =&gt;</span> (</span><br><span class="line">    &lt;li key=&#123;item.id&#125;&gt;&#123;item.name&#125;&lt;<span class="regexp">/li&gt;</span></span><br><span class="line"><span class="regexp">  ))&#125;</span></span><br><span class="line"><span class="regexp">&lt;/u</span>l&gt;</span><br></pre></td></tr></table></figure><h2 id="React-中给-JSX-添加样式"><a href="#React-中给-JSX-添加样式" class="headerlink" title="React 中给 JSX 添加样式"></a>React 中给 JSX 添加样式</h2><ul><li>行内样式（style） 不推荐</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> h1 = (</span><br><span class="line">  &lt;h1 style=&#123;&#123; <span class="attr">color</span>: <span class="string">'red'</span>, <span class="attr">fontSize</span>: <span class="number">30</span>, <span class="attr">backgroundColor</span>: <span class="string">'hotpink'</span> &#125;&#125;&gt;</span><br><span class="line">    我变大了</span><br><span class="line">  &lt;<span class="regexp">/h1&gt;</span></span><br><span class="line"><span class="regexp">)</span></span><br></pre></td></tr></table></figure><ul><li>className 类名 — 推荐！！！</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> h1 = &lt;h1 className="pink"&gt;我变大了&lt;/h1&gt;</span><br></pre></td></tr></table></figure><h2 id="案例"><a href="#案例" class="headerlink" title="案例"></a>案例</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">;[</span><br><span class="line">  &#123; <span class="attr">user</span>: <span class="string">'张三'</span>, <span class="attr">content</span>: <span class="string">'哈哈，沙发'</span> &#125;,</span><br><span class="line">  &#123; <span class="attr">user</span>: <span class="string">'张三2'</span>, <span class="attr">content</span>: <span class="string">'哈哈，板凳'</span> &#125;,</span><br><span class="line">  &#123; <span class="attr">user</span>: <span class="string">'张三3'</span>, <span class="attr">content</span>: <span class="string">'哈哈，凉席'</span> &#125;,</span><br><span class="line">  &#123; <span class="attr">user</span>: <span class="string">'张三4'</span>, <span class="attr">content</span>: <span class="string">'哈哈，砖头'</span> &#125;,</span><br><span class="line">  &#123; <span class="attr">user</span>: <span class="string">'张三5'</span>, <span class="attr">content</span>: <span class="string">'哈哈，楼下山炮'</span> &#125;</span><br><span class="line">]</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      react基础
    
    </summary>
    
      <category term="React" scheme="https://cassielee.top/categories/React/"/>
    
    
      <category term="React" scheme="https://cassielee.top/tags/React/"/>
    
  </entry>
  
</feed>
