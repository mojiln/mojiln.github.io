<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>CassieLee.Blog</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://cassielee.top/"/>
  <updated>2019-08-04T12:54:18.146Z</updated>
  <id>https://cassielee.top/</id>
  
  <author>
    <name>CassieLee</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>JS面试题</title>
    <link href="https://cassielee.top/2019/07/25/JS%E9%9D%A2%E8%AF%95%E9%A2%98/"/>
    <id>https://cassielee.top/2019/07/25/JS面试题/</id>
    <published>2019-07-25T08:08:50.000Z</published>
    <updated>2019-08-04T12:54:18.146Z</updated>
    
    <content type="html"><![CDATA[<pre><code>根据日常总结的知识点进行分析</code></pre><a id="more"></a><hr><h2 id="调用-new-的-4-件事"><a href="#调用-new-的-4-件事" class="headerlink" title="调用 new 的 4 件事"></a>调用 new 的 4 件事</h2><ul><li>创建一个新对象</li><li>将对象里面的 this 指向这个新的对象</li><li>将新对象连接到构造函数的原型</li><li>返回这个对象</li></ul><h2 id="闭包"><a href="#闭包" class="headerlink" title="闭包"></a>闭包</h2><p>函数 A 内部有一个函数 B，函数 B 可以访问带函数 A 中的变量，那么函数 B 就是闭包</p><p>私有变量</p><p>案例：沙箱</p>]]></content>
    
    <summary type="html">
    
      &lt;pre&gt;&lt;code&gt;根据日常总结的知识点进行分析&lt;/code&gt;&lt;/pre&gt;
    
    </summary>
    
      <category term="面试题" scheme="https://cassielee.top/categories/%E9%9D%A2%E8%AF%95%E9%A2%98/"/>
    
    
      <category term="面试题" scheme="https://cassielee.top/tags/%E9%9D%A2%E8%AF%95%E9%A2%98/"/>
    
  </entry>
  
  <entry>
    <title>Vue面试题总结</title>
    <link href="https://cassielee.top/2019/07/19/%E9%9D%A2%E8%AF%95%E9%A2%98%20-%20Vue/"/>
    <id>https://cassielee.top/2019/07/19/面试题 - Vue/</id>
    <published>2019-07-19T12:10:02.000Z</published>
    <updated>2019-08-05T02:13:37.035Z</updated>
    
    <content type="html"><![CDATA[<pre><code>Vue面试题</code></pre><a id="more"></a><h2 id="v-if-和-v-show-区别"><a href="#v-if-和-v-show-区别" class="headerlink" title="v-if 和 v-show 区别"></a>v-if 和 v-show 区别</h2><p><code>v-show</code>指令仅仅控制元素的显示方式，将<code>display:none</code>属性在 block 和 none 来回切换<br><code>v-if</code>指令会控制这个 DOM 节点的存在与否<br>当我们需要经常切换某个元素的显示/隐藏时，使用 v-show 会更加节省性能;当只需要一次显示或隐藏时，使用 v-if</p><hr><h2 id="Vue-的数据双向绑定原理"><a href="#Vue-的数据双向绑定原理" class="headerlink" title="Vue 的数据双向绑定原理"></a>Vue 的数据双向绑定原理</h2><p>采用<strong>数据劫持结合发布者-订阅者模式</strong>的方式，通过 Object.defineProperty()来劫持各个属性的 setter，getter,在数据变动时发布消息给订阅者，触发响应的监听回调。</p><hr><h2 id="Vue-组件间是怎么通讯的"><a href="#Vue-组件间是怎么通讯的" class="headerlink" title="Vue 组件间是怎么通讯的"></a>Vue 组件间是怎么通讯的</h2><hr><h2 id="常见指令"><a href="#常见指令" class="headerlink" title="常见指令"></a>常见指令</h2><hr><h2 id="怎么定义组件"><a href="#怎么定义组件" class="headerlink" title="怎么定义组件"></a>怎么定义组件</h2><hr><h2 id="Vue-路由是怎么做的（路由的原理）"><a href="#Vue-路由是怎么做的（路由的原理）" class="headerlink" title="Vue 路由是怎么做的（路由的原理）"></a>Vue 路由是怎么做的（路由的原理）</h2><hr><h2 id="怎么请求数据"><a href="#怎么请求数据" class="headerlink" title="怎么请求数据"></a>怎么请求数据</h2><hr><h2 id="谈谈组件化和模块化的区别、"><a href="#谈谈组件化和模块化的区别、" class="headerlink" title="谈谈组件化和模块化的区别、"></a>谈谈组件化和模块化的区别、</h2><p><code>模块化</code>：是从代码逻辑的角度进行划分的，方便代码分层开发，保证每个功能模块的职能单一<br><code>组件化</code>：是从 UI 的角度进行划分的，前端的组件化，方便 UI 组件的复用</p><hr><h2 id="Vue-全家桶"><a href="#Vue-全家桶" class="headerlink" title="Vue 全家桶"></a>Vue 全家桶</h2><hr><h2 id="Vuex-的使用和五个核心"><a href="#Vuex-的使用和五个核心" class="headerlink" title="Vuex 的使用和五个核心"></a>Vuex 的使用和五个核心</h2>]]></content>
    
    <summary type="html">
    
      &lt;pre&gt;&lt;code&gt;Vue面试题&lt;/code&gt;&lt;/pre&gt;
    
    </summary>
    
      <category term="面试题" scheme="https://cassielee.top/categories/%E9%9D%A2%E8%AF%95%E9%A2%98/"/>
    
    
      <category term="面试题" scheme="https://cassielee.top/tags/%E9%9D%A2%E8%AF%95%E9%A2%98/"/>
    
  </entry>
  
  <entry>
    <title>面试题总结</title>
    <link href="https://cassielee.top/2019/07/19/%E9%9D%A2%E8%AF%95%E9%A2%98/"/>
    <id>https://cassielee.top/2019/07/19/面试题/</id>
    <published>2019-07-19T12:10:02.000Z</published>
    <updated>2019-08-05T01:40:00.862Z</updated>
    
    <content type="html"><![CDATA[<pre><code>根据日常总结的知识点进行分析</code></pre><a id="more"></a><hr><h2 id="写-React-Vue-项目时为什么要在列表组件中写-key，其作用是什么"><a href="#写-React-Vue-项目时为什么要在列表组件中写-key，其作用是什么" class="headerlink" title="写 React / Vue 项目时为什么要在列表组件中写 key，其作用是什么"></a>写 React / Vue 项目时为什么要在列表组件中写 key，其作用是什么</h2><p>解析：（Vue/React）key 的作用是为了在 diff 算法执行时更快的找到对应的节点，提高 diff 速度</p><p>(Vue)key 的作用是为了在数据变化时强制更新组件，以避免“原地复用”带来的副作用。</p><hr><h2 id="从用户刷新网页开始，一次-js-请求一般情况下有哪些地方会有缓存处理"><a href="#从用户刷新网页开始，一次-js-请求一般情况下有哪些地方会有缓存处理" class="headerlink" title="从用户刷新网页开始，一次 js 请求一般情况下有哪些地方会有缓存处理"></a>从用户刷新网页开始，一次 js 请求一般情况下有哪些地方会有缓存处理</h2><p>解析：DNS 缓存、CDN 缓存、浏览器缓存、服务器缓存</p><h3 id="DNS-缓存-即-（Domain-Name-System-域名系统）"><a href="#DNS-缓存-即-（Domain-Name-System-域名系统）" class="headerlink" title="DNS 缓存 即 （Domain Name System 域名系统）"></a>DNS 缓存 即 （Domain Name System 域名系统）</h3><p>为了增加访问效率， 计算机有域名缓存机制。即当访问过某个网站并得到其 IP 后，会将其域名和 IP 缓存下来， 下一次访问的时候，就不需要再请求域名服务器获取 IP, 直接使用缓存中的 IP，提高了响应的速度。 当前缓存时间是有有效时间的，当过了有效时间后， 还是需要先请求域名解析。</p><p>扩： DNS 预解析</p><p>因为在调用当前页面所在域名外的域名文件时，会遇到请求延时非常严重的情况。<br>我们可以使用 DNS 预解析。</p><ol><li>用 meta 信息来告知浏览器，当前页面要做 DNS 预解析：</li></ol><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;meta http-equiv=<span class="string">"x-dns-prefetch-control"</span> content=<span class="string">"on"</span> /&gt;</span><br></pre></td></tr></table></figure><p>在页面 header 中使用 link 标签来强制对 DNS 预解析</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">link</span> <span class="attr">rel</span>=<span class="string">"dns-prefetch"</span> <span class="attr">href</span>=<span class="string">"http://bdimg.share.baidu.com"</span> /&gt;</span></span><br></pre></td></tr></table></figure><h3 id="CDN-即-（Content-Delivery-NetWork）-内容分发网络"><a href="#CDN-即-（Content-Delivery-NetWork）-内容分发网络" class="headerlink" title="CDN 即 （Content Delivery NetWork） 内容分发网络"></a>CDN 即 （Content Delivery NetWork） 内容分发网络</h3><p>CDN 是构建在网络之上的内容分发网络，依靠部署在各地的边缘服务器，通过中心平台的负载均衡、内容分发、调度等功能模块，使用户就近获取所需内容，降低网络拥塞，提高用户访问响应速度和命中率。CDN 的关键技术主要有内容存储和分发技术。</p><p>通俗解释：就是当我们发送一个 web 请求时，会先经过它一道手，然后它帮我们计算路径，去哪得到这些东东（representations）的路径短且快。这个是网站管理员部署的，所以他们也可以将大家经常访问的 representations 放在 CDN 里，这样，就响应就更快了。</p><h3 id="浏览器缓存"><a href="#浏览器缓存" class="headerlink" title="浏览器缓存"></a>浏览器缓存</h3><p>通过浏览器实现 HTTP 缓存。</p><p>Expires<br>添加 Expires 头能有效的利用浏览器的缓存能力来改善页面的性能，能在后续的页面中有效避免很多不必要的 Http 请求，WEB 服务器使用 Expires 头来告诉 Web 客户端它可以使用一个组件的当前副本，直到指定的时间为止。</p><p>例如：Expires：Thu，15 Apr 2010 20：00：00 GMT; 他告诉浏览器缓存有效性持续到 2010 年 4 月 15 日为止，在这个时间之内相同的请求使用缓存，这个时间之外使用 http 请求。</p><p>Cathe-Control<br>使用 max-age 指定组件被缓存多久，从请求开始在 max-age 时间内浏览器使用缓存，之外的使用请求，这样就可以消除 Expires 的限制.</p><p>例如：Cathe-Control：max-age=315360000</p><h3 id="服务器缓存"><a href="#服务器缓存" class="headerlink" title="服务器缓存"></a>服务器缓存</h3><p>服务器缓存一般指缓存服务器<br>缓存指的是将需要频繁访问的网络内容存放在离用户较近、访问速度更快的系统中，以提高内容访问速度的一种技术。缓存服务器就是存放频繁访问内容的服务器。</p><hr><h2 id="Javascript：history-go-和-history-back-的用法与区别"><a href="#Javascript：history-go-和-history-back-的用法与区别" class="headerlink" title="Javascript：history.go()和 history.back()的用法与区别"></a>Javascript：history.go()和 history.back()的用法与区别</h2><p>go() 方法可加载历史列表中的某个具体的页面。<br>该参数可以是数字，使用的是要访问的 URL 在 History 的 URL 列表中的相对位置。（-1 上一个页面，1 前进一个页面)。或一个字符串，字符串必须是局部或完整的 URL，该函数会去匹配字符串的第一个 URL。</p><p>go(-1):返回上一页，原页面表单中的内容会丢失；<br>back():返回上一页，原页表表单中的内容会保留。</p><hr><h2 id="什么是防抖和节流？有什么区别？如何实现"><a href="#什么是防抖和节流？有什么区别？如何实现" class="headerlink" title="什么是防抖和节流？有什么区别？如何实现"></a>什么是防抖和节流？有什么区别？如何实现</h2><p>防抖(debounce)<br>触发高频事件后 n 秒内函数只会执行一次，如果 n 秒内高频事件再次被触发，则重新计算时间(函数防抖: 任务频繁触发的情况下，只有任务触发的间隔超过指定间隔的时候，任务才会执行。)</p><p>思路：<br>每次触发事件时都取消之前的延时调用方法</p><p>其实函数防抖的原理也非常地简单，通过闭包保存一个标记来保存 setTimeout 返回的值，每当用户输入的时候把前一个 setTimeout clear 掉，然后又创建一个新的 setTimeout，这样就能保证输入字符后的 interval 间隔内如果还有字符输入的话，就不会执行 fn 函数了。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">debounce</span>(<span class="params">fn</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> timeout = <span class="literal">null</span> <span class="comment">// 创建一个标记用来存放定时器的返回值</span></span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    clearTimeout(timeout) <span class="comment">// 每当用户输入的时候把前一个 setTimeout clear 掉</span></span><br><span class="line">    timeout = setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">      <span class="comment">// 然后又创建一个新的 setTimeout, 这样就能保证输入字符后的 interval 间隔内如果还有字符输入的话，就不会执行 fn 函数</span></span><br><span class="line">      fn.apply(<span class="keyword">this</span>, <span class="built_in">arguments</span>)</span><br><span class="line">    &#125;, <span class="number">500</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">sayHi</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'防抖成功'</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> inp = <span class="built_in">document</span>.getElementById(<span class="string">'inp'</span>)</span><br><span class="line">inp.addEventListener(<span class="string">'input'</span>, debounce(sayHi)) <span class="comment">// 防抖</span></span><br></pre></td></tr></table></figure><p>节流(throttle)<br>高频事件触发，但在 n 秒内只会执行一次，所以节流会稀释函数的执行频率(函数节流: 指定时间间隔内只会执行一次任务)</p><p>思路：<br>每次触发事件时都判断当前是否有等待执行的延时函数</p><p>简单来说，函数的节流就是通过闭包保存一个标记（canRun = true），在函数的开头判断这个标记是否为 true，如果为 true 的话就继续执行函数，否则则 return 掉，判断完标记后立即把这个标记设为 false，然后把外部传入的函数的执行包在一个 setTimeout 中，最后在 setTimeout 执行完毕后再把标记设置为 true（这里很关键），表示可以执行下一次的循环了。当 setTimeout 还未执行的时候，canRun 这个标记始终为 false，在开头的判断中被 return 掉</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">throttle</span>(<span class="params">fn</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> canRun = <span class="literal">true</span> <span class="comment">// 通过闭包保存一个标记</span></span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!canRun) <span class="keyword">return</span> <span class="comment">// 在函数开头判断标记是否为true，不为true则return</span></span><br><span class="line">    canRun = <span class="literal">false</span> <span class="comment">// 立即设置为false</span></span><br><span class="line">    setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">      <span class="comment">// 将外部传入的函数的执行放在setTimeout中</span></span><br><span class="line">      fn.apply(<span class="keyword">this</span>, <span class="built_in">arguments</span>)</span><br><span class="line">      <span class="comment">// 最后在setTimeout执行完毕后再把标记设置为true(关键)表示可以执行下一次循环了。当定时器没有执行的时候标记永远是false，在开头被return掉</span></span><br><span class="line">      canRun = <span class="literal">true</span></span><br><span class="line">    &#125;, <span class="number">500</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">sayHi</span>(<span class="params">e</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(e.target.innerWidth, e.target.innerHeight)</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">window</span>.addEventListener(<span class="string">'resize'</span>, throttle(sayHi))</span><br></pre></td></tr></table></figure><p>总结：其实函数节流与函数防抖的原理非常简单，巧妙地使用 setTimeout 来存放待执行的函数，这样可以很方便的利用 clearTimeout 在合适的时机来清除待执行的函数。<br>使用函数节流与函数防抖的目的，在开头的栗子中应该也能看得出来，就是为了节约计算机资源。</p><hr>]]></content>
    
    <summary type="html">
    
      &lt;pre&gt;&lt;code&gt;根据日常总结的知识点进行分析&lt;/code&gt;&lt;/pre&gt;
    
    </summary>
    
      <category term="面试题" scheme="https://cassielee.top/categories/%E9%9D%A2%E8%AF%95%E9%A2%98/"/>
    
    
      <category term="面试题" scheme="https://cassielee.top/tags/%E9%9D%A2%E8%AF%95%E9%A2%98/"/>
    
  </entry>
  
  <entry>
    <title>Hello World</title>
    <link href="https://cassielee.top/2019/07/16/hello-world/"/>
    <id>https://cassielee.top/2019/07/16/hello-world/</id>
    <published>2019-07-16T03:05:17.329Z</published>
    <updated>2019-07-16T03:05:17.329Z</updated>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="noopener">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="noopener">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="noopener">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">"My New Post"</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="noopener">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="noopener">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="noopener">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/deployment.html" target="_blank" rel="noopener">Deployment</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;Welcome to &lt;a href=&quot;https://hexo.io/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Hexo&lt;/a&gt;! This is your very first post. Check &lt;a href=&quot;https://hexo.
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>js 的继承机制</title>
    <link href="https://cassielee.top/2019/01/19/js%E7%BB%A7%E6%89%BF%E6%9C%BA%E5%88%B6/"/>
    <id>https://cassielee.top/2019/01/19/js继承机制/</id>
    <published>2019-01-19T11:10:02.000Z</published>
    <updated>2019-07-29T06:27:59.813Z</updated>
    
    <content type="html"><![CDATA[<h1 id="js-的继承机制"><a href="#js-的继承机制" class="headerlink" title="js 的继承机制"></a>js 的继承机制</h1><a id="more"></a><h2 id="ES5-和-ES6-及继承机制"><a href="#ES5-和-ES6-及继承机制" class="headerlink" title="ES5 和 ES6 及继承机制"></a>ES5 和 ES6 及继承机制</h2><p>这几天在学习 react 的时候学习到 ES6 的 class extends 继承方式，就复习一下 ES5 的继承机制，并整理下来。</p><h2 id="ES5-继承机制"><a href="#ES5-继承机制" class="headerlink" title="ES5 继承机制"></a>ES5 继承机制</h2><p>在 js 万物皆对象，但事还是区分普通对象和函数对象，那大家需要知道是只有函数对象才有 <code>prototype</code> 属性，但所有对象都有<code>__proto__</code>属性</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">A</span>(<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line"><span class="keyword">var</span> B = <span class="keyword">new</span> A()</span><br></pre></td></tr></table></figure><p>那这里就得出几个公式：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">B.**proto**== A.prototype;</span><br><span class="line">B.constructor == A;</span><br><span class="line">a.prototype.constuctor = A;</span><br></pre></td></tr></table></figure><p>那这是实现继承的基础； 也就是说 A.prototype 是 A 的原型对象，A 是构造函数，B 是 A 的实例，原型对象（A.prototype）是 构造函数（A）的一个实例。而此时 this 指向是指向实例。 明白这个关系实现继承就很简单了！看一下下面的代码</p><h3 id="原型链继承"><a href="#原型链继承" class="headerlink" title="原型链继承"></a>原型链继承</h3><p>通过重写子类的原型 等于 父类的一个实例，（父类的实例属相变成子类的原型属性）</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">father</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.faName = <span class="string">'father'</span></span><br><span class="line">&#125;</span><br><span class="line">father.prototype.getfaName = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="keyword">this</span>.faName)</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">child</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.chName = <span class="string">'child'</span></span><br><span class="line">&#125;</span><br><span class="line">child.prototype = <span class="keyword">new</span> father()</span><br><span class="line">child.prototype.constructor = child</span><br><span class="line">child.prototype.getchName = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="keyword">this</span>.chName)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="组合继承-（比较常用，也有缺点）"><a href="#组合继承-（比较常用，也有缺点）" class="headerlink" title="组合继承 （比较常用，也有缺点）"></a>组合继承 （比较常用，也有缺点）</h3><p>通过子类的原型对象指向父类实例的方式来实现继承，那我们不难发现原型链的形成是真正是靠<code>__proto__</code> 而非 prototype，子类的实例可以访问父类原型上的方法，是因为子类实例通过<code>__proto__</code>与父类的原型对象有连接</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//先来个父类，带些属性</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Super</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.flag = <span class="literal">true</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//为了提高复用性，方法绑定在父类原型属性上</span></span><br><span class="line">Super.prototype.getFlag = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">this</span>.flag</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//来个子类</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Sub</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.subFlag = <span class="literal">false</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//实现继承</span></span><br><span class="line">Sub.prototype = <span class="keyword">new</span> Super()</span><br><span class="line"><span class="comment">//给子类添加子类特有的方法，注意顺序要在继承之后</span></span><br><span class="line">Sub.prototype.getSubFlag = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">this</span>.subFlag</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//构造实例</span></span><br><span class="line"><span class="keyword">var</span> es5 = <span class="keyword">new</span> Sub()</span><br></pre></td></tr></table></figure><h3 id="寄生组合继承-（业内比较提倡的方法）"><a href="#寄生组合继承-（业内比较提倡的方法）" class="headerlink" title="寄生组合继承 （业内比较提倡的方法）"></a>寄生组合继承 （业内比较提倡的方法）</h3><p>所谓寄生组合式继承，即通过借助构造函数来继承属性，通过原型链的混成形式来继承方法。 其背后的基本思路是：不必为了指定子类型的原型而调用超类型的构造函数，我们所需要的无非就是超类型原型的一个副本而已。本质上，就是使用寄生式继承来继承超类型的原型，然后再将结果指定给子类型的原型。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">inserit</span>(<span class="params">son, father</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> obj = <span class="built_in">Object</span>.create(father.prototype)</span><br><span class="line">  son.prototype = obj</span><br><span class="line">  obj.constructor = son</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">SuperType</span>(<span class="params">name, colors</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.name = name</span><br><span class="line">  <span class="keyword">this</span>.colors = colors</span><br><span class="line">&#125;</span><br><span class="line">SuperType.prototype.sayName = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">this</span>.name</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">SubType</span>(<span class="params">job, name, color</span>) </span>&#123;</span><br><span class="line">  SuperType.call(<span class="keyword">this</span>, name, color)</span><br><span class="line">  <span class="keyword">this</span>.job = job</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//核心方法</span></span><br><span class="line">inserit(SubType, SuperType)</span><br><span class="line">SubType.prototype.sayjob = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">this</span>.job</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> instance = <span class="keyword">new</span> SubType(<span class="string">'doctor'</span>, <span class="string">'John'</span>, [<span class="string">'red'</span>, <span class="string">'green'</span>])</span><br><span class="line"><span class="built_in">console</span>.log(instance.sayjob(), instance.sayName()) <span class="comment">//doctor,John</span></span><br></pre></td></tr></table></figure><p>[x] 原型链继承缺点：父类包含引用类型的属性，那么子类所有实例都会共享该属性（包含引用类型的原型属性会被实例共享），在创建子类实例时，不能向父类的构造函数传递参数<br>[x] 组合继承的缺点：两次调用父类构造函数：（第一次是在创建子类原型的时候，第二次是在子类构造函数内部）子类继承父类的属性，一组在子类实例上，一组在子类原型上（在子类原型上创建不必要的多余的属性）（实例上的屏蔽原型上的同名属性）效率低<br>[x] 组合继承的优点：只调用一次父类的构造函数,避免了在子类原型上创建不必要的，多余的属性，原型链保持不变<br>ES5 的继承机制总结<br>ES5 的继承机制简单来说就是：实质是先创造子类的实例对象 this，然后再将父类的方法添加到 this 上面（Parent.apply(this)）</p><h2 id="ES6-的继承机制"><a href="#ES6-的继承机制" class="headerlink" title="ES6 的继承机制"></a>ES6 的继承机制</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Point</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>(x) &#123;</span><br><span class="line">    <span class="keyword">this</span>.x = <span class="number">1</span></span><br><span class="line">    <span class="keyword">this</span>.p = <span class="number">2</span></span><br><span class="line">  &#125;</span><br><span class="line">  print() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.x</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">Point.prototype.z = <span class="string">'4'</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ColorPoint</span> <span class="keyword">extends</span> <span class="title">Point</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>(x) &#123;</span><br><span class="line">    <span class="keyword">this</span>.color = color <span class="comment">// ReferenceError</span></span><br><span class="line">    <span class="keyword">super</span>(x, y)</span><br><span class="line">    <span class="keyword">this</span>.x = x <span class="comment">// 正确</span></span><br><span class="line">  &#125;</span><br><span class="line">  m() &#123;</span><br><span class="line">    <span class="keyword">super</span>.print()</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>ES6 继承是通过 <strong>class</strong>、<strong>extends</strong> 关键字来实现继承 Point 是父类，ColorPoint 是子类 通过 class 新建子类 extends 继承父类的方式实现继承，方式比 ES5 简单的多。</p><h3 id="constructor-NaN"><a href="#constructor-NaN" class="headerlink" title="constructor"></a>constructor</h3><p>constructor 方法是类的构造函数，是一个默认方法，通过 new 命令创建对象实例时，自动调用该方法。一个类必须有 constructor 方法，如果没有显式定义，一个默认的 consructor 方法会被默认添加。所以即使你没有添加构造函数，也是会有一个默认的构造函数的。一般 constructor 方法返回实例对象 this ，但是也可以指定 constructor 方法返回一个全新的对象，让返回的实例对象不是该类的实例。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Points</span> </span>&#123;</span><br><span class="line"><span class="keyword">constructor</span>(x) &#123;</span><br><span class="line"><span class="keyword">this</span>.x = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">this</span>.p = <span class="number">2</span>;</span><br><span class="line">&#125;</span><br><span class="line">print() &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">this</span>.x;</span><br><span class="line">&#125;</span><br><span class="line">statc getname()&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">new</span>.target.name;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 等同于：</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Points</span>(<span class="params">x</span>) </span>&#123;</span><br><span class="line"><span class="keyword">this</span>.x = x;</span><br><span class="line"><span class="keyword">this</span>.p = <span class="number">2</span>;</span><br><span class="line">&#125;</span><br><span class="line">Points.prototype.print = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="string">'('</span> + <span class="keyword">this</span>.x +<span class="string">')'</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>也就是说 constructor 就代表在父类上加属性，而在 class 对象加方法属性 等于在原型上的加。而这些属性方法 只有通过 new 出的实例 或者是 extends 继承出来的实例才可以获取到 所以我们可以得到</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> Points().__proto__.print() <span class="comment">//可以调用到 Points 的 print 方法</span></span><br><span class="line"><span class="keyword">new</span> Points().x = <span class="number">1</span> <span class="comment">//可以调用到 constructor 里面的 this.x=1</span></span><br></pre></td></tr></table></figure><h3 id="super"><a href="#super" class="headerlink" title="super"></a>super</h3><p>super 既可以当做函数使用，也可以当做对象使用两种使用的时候完全不一样， 函数用时 : 在 constructor 中必须调用 super 方法，因为子类没有自己的 this 对象，而是继承父类的 this 对象，然后对其进行加工,而 super 就代表了父类的构造函数。super 虽然代表了父类 A 的构造函数，但是返回的是子类 B 的实例，即 super 内部的 this 指的是 B，因此 super() 在这里相当于</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">A.prototype.constructor.call(<span class="keyword">this</span>, props)</span><br></pre></td></tr></table></figure><p>在 super() 执行时，它指向的是 子类 B 的构造函数，而不是父类 A 的构造函数。也就是说，super() 内部的 this 指向的是 B。所以在第一个 es6 的例子中子类的 this 指向的是自己。、</p><p><strong>当做对象使用</strong> ： 在普通方法中，指向父类的原型对象；在静态方法中，指向父类。 所以在子类的方法中 super.print();指向的是父类原型上的方法。 <strong>但是因为 super 的两种用法，所以 es6 规定在使用必须要明确使用方式，像单独 console.log(super) 就会报错。</strong></p><h3 id="static"><a href="#static" class="headerlink" title="static"></a>static</h3><p>顾名思义是静态方法的意思，类相当于实例的原型， 所有在类中定义的方法， 都会被实例继承。 如果在一个方法前， 加上 static 关键字， 就表示该方法不会被实例继承， 而是直接通过类来调用， 这就称为“ 静态方法”。静态方法调用直接在类上进行，而在类的实例上不可被调用。静态方法通常用于创建 实用/工具 函数。</p><h3 id="new-target"><a href="#new-target" class="headerlink" title="new.target"></a>new.target</h3><p>new.target 属性允许你检测函数或构造方法是否通过是通过 new 运算符被调用的。在通过 new 运算符被初始化的函数或构造方法中，new.target 返回一个指向构造方法或函数的引用。在普通的函数调用中，new.target 的值是 undefined。</p><p>也就是说 new.target 的功能就是用来检测函数的调用是不是通过 new 去创建一个新对象的，而且 new.target 返回的是一个指向函数的引用，也就是说我们能够确定是哪个函数进行了 new 操作。</p><h2 id="ES6-的继承机制总结"><a href="#ES6-的继承机制总结" class="headerlink" title="ES6 的继承机制总结"></a>ES6 的继承机制总结</h2><p>先创建父类实例 this 通过 <strong>class</strong>、 <strong>extends</strong> 、<strong>super</strong> 关键字定义子类，并改变 this 指向,super 本身是指向父类的构造函数但做函数调用后返回的是子类的实例，实际上做了父类.prototype.constructor.call(this)，做对象调用时指向父类.prototype,从而实现继承。</p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;js-的继承机制&quot;&gt;&lt;a href=&quot;#js-的继承机制&quot; class=&quot;headerlink&quot; title=&quot;js 的继承机制&quot;&gt;&lt;/a&gt;js 的继承机制&lt;/h1&gt;
    
    </summary>
    
      <category term="面试题" scheme="https://cassielee.top/categories/%E9%9D%A2%E8%AF%95%E9%A2%98/"/>
    
    
      <category term="面试题" scheme="https://cassielee.top/tags/%E9%9D%A2%E8%AF%95%E9%A2%98/"/>
    
  </entry>
  
  <entry>
    <title>React的基本使用</title>
    <link href="https://cassielee.top/2018/07/19/React%E7%9A%84%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8/"/>
    <id>https://cassielee.top/2018/07/19/React的基本使用/</id>
    <published>2018-07-19T12:52:02.000Z</published>
    <updated>2019-07-28T11:55:19.069Z</updated>
    
    <content type="html"><![CDATA[<h2 id="react-是什么"><a href="#react-是什么" class="headerlink" title="react 是什么"></a>react 是什么</h2><ul><li>React 是一个 JS 库，用来构建用户界面（写 HTML，构建 web 应用）</li><li>从 MVC 的角度来看，相当于 视图层 V（View） 的内容。</li></ul><h2 id="react-的特点"><a href="#react-的特点" class="headerlink" title="react 的特点"></a>react 的特点</h2><ul><li>声明式： 我们只需要描述页面长什么样子就可以了，React 负责更新页面</li><li>基于组件（组件化）</li><li>学习一次，随处使用（Web 、 安卓/ios、vr …）</li></ul><h2 id="React-的基本使用"><a href="#React-的基本使用" class="headerlink" title="React 的基本使用"></a>React 的基本使用</h2><ul><li><p>安装：npm i react react-dom</p></li><li><p>引入 react 和 react-dom 两个 js 文件（注意：引入顺序，react 在前，react-dom 在后）</p></li><li><p>创建 React 元素</p><ul><li><code>const h1 = React.createElement(&#39;h1&#39;, null, &#39;子节点&#39;)</code></li></ul></li><li><p>渲染创建好的 React 元素，到页面中</p><ul><li><code>ReactDOM.render(h1, document.getElementById(&#39;root&#39;))</code></li></ul></li></ul><h2 id="React-createElement-方法的说明"><a href="#React-createElement-方法的说明" class="headerlink" title="React.createElement() 方法的说明"></a>React.createElement() 方法的说明</h2><ul><li>作用：创建 react 元素的</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建React元素</span></span><br><span class="line"><span class="comment">// 第一个参数：表示要创建什么元素，就是 HTML 标签名称</span></span><br><span class="line"><span class="comment">// 第二个参数：表示元素自身属性，如果没有就传 null</span></span><br><span class="line"><span class="comment">//  如果要指定元素自身的属性，就传递一个对象（&#123;&#125;）</span></span><br><span class="line"><span class="comment">//  1 class ==&gt; className</span></span><br><span class="line"><span class="comment">//  2 for ==&gt; htmlFor</span></span><br><span class="line"><span class="comment">// 第三个及其以后的参数：表示元素的子节点（文本、元素节点）</span></span><br><span class="line"><span class="comment">//  如果是文本节点，就直接传递 字符串。</span></span><br><span class="line"><span class="comment">//  如果是元素节点，就继续调用 React.createElement() 方法，创建新的React元素节点</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// const h1 = React.createElement('div', null, 'Hello React')</span></span><br><span class="line"><span class="keyword">const</span> h1 = React.createElement(</span><br><span class="line">  <span class="string">'h1'</span>,</span><br><span class="line">  &#123;</span><br><span class="line">    id: <span class="string">'title'</span>,</span><br><span class="line">    className: <span class="string">'cls'</span>,</span><br><span class="line">    htmlFor: <span class="string">'d'</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="string">'Hello React'</span>,</span><br><span class="line">  <span class="string">'test 文本节点'</span>,</span><br><span class="line">  React.createElement(<span class="string">'span'</span>, <span class="literal">null</span>, <span class="string">'这是一个span'</span>)</span><br><span class="line">)</span><br></pre></td></tr></table></figure><h2 id="React-脚手架初始化项目的步骤"><a href="#React-脚手架初始化项目的步骤" class="headerlink" title="React 脚手架初始化项目的步骤"></a>React 脚手架初始化项目的步骤</h2><ul><li>命令：<code>npx create-react-app 项目名称</code><ul><li>比如：<code>npx create-react-app my-app</code></li></ul></li><li>npx 命令：简化使用脚手架初始化项目的流程<ul><li>不使用 npx：1 先全局安装脚手架的包 2 使用脚手架包提供的命令来初始化项目</li><li>使用 npx：不需要再全局安装脚手架的包，直接就可以初始化项目</li></ul></li><li>如何启动项目？进入项目根目录然后，执行以下命令<ul><li>yarn start</li><li>npm start</li></ul></li></ul><h2 id="在脚手架中使用-react"><a href="#在脚手架中使用-react" class="headerlink" title="在脚手架中使用 react"></a>在脚手架中使用 react</h2><ul><li>导入<ul><li><code>import React from &#39;react&#39;</code></li><li><code>import ReactDOM from &#39;react-dom&#39;</code></li></ul></li></ul><h2 id="JSX"><a href="#JSX" class="headerlink" title="JSX"></a>JSX</h2><ul><li>为什么要学习 JSX ？<ul><li>因为 createElement 形式，太繁琐，不直观，书写效率不高，所以，我们不想用这种方式。</li><li>JSX 特点：不反锁，直观，书写效率高</li></ul></li><li>JSX 是什么？ JavaScript XML（HTML），也就是在 JS 中书写 HTMl 格式的代码</li></ul><h2 id="JSX-的基本使用"><a href="#JSX-的基本使用" class="headerlink" title="JSX 的基本使用"></a>JSX 的基本使用</h2><ul><li><p>导入 react 和 react-dom</p></li><li><p>使用 JSX 语法创建 React 元素</p><ul><li>JSX 就跟写 HTML 一样</li></ul></li><li><p>渲染创建好的 React 元素</p></li></ul><h2 id="JSX-语法的注意点"><a href="#JSX-语法的注意点" class="headerlink" title="JSX 语法的注意点"></a>JSX 语法的注意点</h2><ul><li><p>JSX 元素的属性名推荐使用：驼峰命名法</p></li><li><p>class ===&gt; className</p></li><li><p>如果元素没有子节点，可以使用 单标签 方式来结束</p><ul><li>比如：<code>&lt;div /&gt;</code></li></ul></li><li><p>推荐使用 () 来包裹 JSX，从而避免 JS 中自动插入分号机制</p></li></ul><h2 id="在-JSX-中使用-JS-表达式（数据）"><a href="#在-JSX-中使用-JS-表达式（数据）" class="headerlink" title="在 JSX 中使用 JS 表达式（数据）"></a>在 JSX 中使用 JS 表达式（数据）</h2><ul><li>语法：使用 {} ，就可以在 JSX 中使用 JS 中的数据了<ul><li><code>&lt;div&gt;Hello {name + &#39;666&#39;}&lt;/div&gt;</code></li></ul></li><li>原则：可以在 {} 中使用任何的 JS 表达式。</li><li>注意：不能在 {} 中，使用 语句！<ul><li>比如： if/for/switch …</li></ul></li><li>注意：不能在 {} 中使用对象，除了 style 属性以外！！！</li><li>JSX 自身也是一个 JS 表达式，所以，可以在 {} 中继续使用 JSX ！！！</li></ul><h2 id="React-的条件渲染"><a href="#React-的条件渲染" class="headerlink" title="React 的条件渲染"></a>React 的条件渲染</h2><ul><li>使用 if/esle 来实现</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> loadData = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">if</span> (isLoading) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span>loading...<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span>加载完成后的列表结构<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> h1 = <span class="xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span>&#123;loadData()&#125;<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br></pre></td></tr></table></figure><ul><li>使用三元表达式</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> loadData = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> isLoading ? <span class="xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span>loading...<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span> : <span class="xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span>加载完成后的列表结构<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>逻辑运算符 &amp;&amp;</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> loadData = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> isLoading &amp;&amp; <span class="xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span>loading...<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="React-中的列表渲染"><a href="#React-中的列表渲染" class="headerlink" title="React 中的列表渲染"></a>React 中的列表渲染</h2><ul><li>使用数组的 map 方法来进行列表渲染</li><li>需要给被遍历生成的元素添加 key 属性，key 应该是唯一的。尽量避免使用 index 作为索引号。</li><li>剩下的就是 JS 中 map 方法的使用了。</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;ul&gt;</span><br><span class="line">  &#123;songs.map(<span class="function"><span class="params">item</span> =&gt;</span> (</span><br><span class="line">    &lt;li key=&#123;item.id&#125;&gt;&#123;item.name&#125;&lt;<span class="regexp">/li&gt;</span></span><br><span class="line"><span class="regexp">  ))&#125;</span></span><br><span class="line"><span class="regexp">&lt;/u</span>l&gt;</span><br></pre></td></tr></table></figure><h2 id="React-中给-JSX-添加样式"><a href="#React-中给-JSX-添加样式" class="headerlink" title="React 中给 JSX 添加样式"></a>React 中给 JSX 添加样式</h2><ul><li>行内样式（style） 不推荐</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> h1 = (</span><br><span class="line">  &lt;h1 style=&#123;&#123; <span class="attr">color</span>: <span class="string">'red'</span>, <span class="attr">fontSize</span>: <span class="number">30</span>, <span class="attr">backgroundColor</span>: <span class="string">'hotpink'</span> &#125;&#125;&gt;</span><br><span class="line">    我变大了</span><br><span class="line">  &lt;<span class="regexp">/h1&gt;</span></span><br><span class="line"><span class="regexp">)</span></span><br></pre></td></tr></table></figure><ul><li>className 类名 — 推荐！！！</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> h1 = <span class="xml"><span class="tag">&lt;<span class="name">h1</span> <span class="attr">className</span>=<span class="string">"pink"</span>&gt;</span>我变大了<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span></span><br></pre></td></tr></table></figure><h2 id="案例"><a href="#案例" class="headerlink" title="案例"></a>案例</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">;[</span><br><span class="line">  &#123; <span class="attr">user</span>: <span class="string">'张三'</span>, <span class="attr">content</span>: <span class="string">'哈哈，沙发'</span> &#125;,</span><br><span class="line">  &#123; <span class="attr">user</span>: <span class="string">'张三2'</span>, <span class="attr">content</span>: <span class="string">'哈哈，板凳'</span> &#125;,</span><br><span class="line">  &#123; <span class="attr">user</span>: <span class="string">'张三3'</span>, <span class="attr">content</span>: <span class="string">'哈哈，凉席'</span> &#125;,</span><br><span class="line">  &#123; <span class="attr">user</span>: <span class="string">'张三4'</span>, <span class="attr">content</span>: <span class="string">'哈哈，砖头'</span> &#125;,</span><br><span class="line">  &#123; <span class="attr">user</span>: <span class="string">'张三5'</span>, <span class="attr">content</span>: <span class="string">'哈哈，楼下山炮'</span> &#125;</span><br><span class="line">]</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      react基础
    
    </summary>
    
      <category term="React" scheme="https://cassielee.top/categories/React/"/>
    
    
      <category term="React" scheme="https://cassielee.top/tags/React/"/>
    
  </entry>
  
  <entry>
    <title>ES6面试题</title>
    <link href="https://cassielee.top/2018/01/19/ES6/"/>
    <id>https://cassielee.top/2018/01/19/ES6/</id>
    <published>2018-01-19T04:10:02.000Z</published>
    <updated>2019-08-05T01:38:07.738Z</updated>
    
    <content type="html"><![CDATA[<pre><code>ES6面试题</code></pre><a id="more"></a><h2 id="普通函数和箭头函数的区别"><a href="#普通函数和箭头函数的区别" class="headerlink" title="普通函数和箭头函数的区别"></a>普通函数和箭头函数的区别</h2><ul><li>箭头函数没有 prototype(原型)，所以箭头函数本身没有 this</li><li>箭头函数的 this 在定义的时候继承自外层第一个普通函数的 this。</li><li>如果箭头函数外层没有普通函数，严格模式和非严格模式下它的 this 都会指向 window(全局对象)</li><li>箭头函数本身的 this 指向不能改变，但可以修改它要继承的对象的 this。</li><li>箭头函数的 this 指向全局，使用 arguments 会报未声明的错误。</li><li>箭头函数的 this 指向普通函数时,它的 argumens 继承于该普通函数</li><li>使用 new 调用箭头函数会报错，因为箭头函数没有 constructor</li><li>箭头函数不支持 new.target</li><li>箭头函数不支持重命名函数参数,普通函数的函数参数支持重命名</li><li>箭头函数相对于普通函数语法更简洁优雅</li></ul><p>箭头函数的注意事项及不适用场景</p><ul><li>箭头函数的注意事项：</li><li>箭头函数一条语句返回对象字面量，需要加括号</li><li>箭头函数在参数和箭头之间不能换行</li><li>箭头函数的解析顺序相对||靠前</li></ul><p>不适用场景：箭头函数的 this 意外指向和代码的可读性。</p><hr><h2 id="Vue-的数据双向绑定原理"><a href="#Vue-的数据双向绑定原理" class="headerlink" title="Vue 的数据双向绑定原理"></a>Vue 的数据双向绑定原理</h2><hr>]]></content>
    
    <summary type="html">
    
      &lt;pre&gt;&lt;code&gt;ES6面试题&lt;/code&gt;&lt;/pre&gt;
    
    </summary>
    
      <category term="面试题" scheme="https://cassielee.top/categories/%E9%9D%A2%E8%AF%95%E9%A2%98/"/>
    
    
      <category term="面试题" scheme="https://cassielee.top/tags/%E9%9D%A2%E8%AF%95%E9%A2%98/"/>
    
  </entry>
  
  <entry>
    <title>Set、Map、WeakSet 和 WeakMap 的区别</title>
    <link href="https://cassielee.top/2018/01/19/ES6%20copy/"/>
    <id>https://cassielee.top/2018/01/19/ES6 copy/</id>
    <published>2018-01-19T04:10:02.000Z</published>
    <updated>2019-08-05T01:39:54.538Z</updated>
    
    <content type="html"><![CDATA[<pre><code>Set、Map、WeakSet 和 WeakMap 的区别</code></pre><a id="more"></a><h2 id="介绍下-Set、Map、WeakSet-和-WeakMap-的区别"><a href="#介绍下-Set、Map、WeakSet-和-WeakMap-的区别" class="headerlink" title="介绍下 Set、Map、WeakSet 和 WeakMap 的区别"></a>介绍下 Set、Map、WeakSet 和 WeakMap 的区别</h2><p>Set 和 Map 主要的应用场景在于 <strong>数据重组</strong> 和 <strong>数据储存</strong></p><p>Set 是一种叫做<strong>集合</strong>的数据结构，Map 是一种叫做<strong>字典</strong>的数据结构</p><h3 id="集合（Set）"><a href="#集合（Set）" class="headerlink" title="集合（Set）"></a>集合（Set）</h3><p>ES6 新增的一种新的数据结构，类似于数组，但成员是唯一且无序的，没有重复的值。</p><p>Set <strong>本身是一种构造函数，用来生成 Set 数据结构</strong>。</p><p>new Set([iterable])<br>举个例子：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> s = <span class="keyword">new</span> <span class="built_in">Set</span>()</span><br><span class="line">[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">3</span>, <span class="number">2</span>, <span class="number">1</span>].forEach(<span class="function"><span class="params">x</span> =&gt;</span> s.add(x))</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i <span class="keyword">of</span> s) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(i) <span class="comment">// 1 2 3 4</span></span><br><span class="line">&#125; <span class="comment">// 去重数组的重复对象</span></span><br><span class="line"><span class="keyword">let</span> arr = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">2</span>, <span class="number">1</span>, <span class="number">1</span>]</span><br><span class="line">[... new <span class="built_in">Set</span>(arr)] <span class="comment">// [1, 2, 3]</span></span><br></pre></td></tr></table></figure><p>Set 对象允许你储存任何类型的唯一值，无论是原始值或者是对象引用。</p><p>向 Set 加入值的时候，不会发生类型转换，所以 5 和”5”是两个不同的值。Set 内部判断两个值是否不同，使用的算法叫做“Same-value-zero equality”，它类似于<strong>精确相等</strong>运算符（===），主要的区别是<strong>NaN 等于自身，而精确相等运算符认为 NaN 不等于自身。</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="keyword">set</span> = new Set()</span><br><span class="line">let a = NaN</span><br><span class="line">let b = NaN</span><br><span class="line"><span class="keyword">set</span>.add(a)</span><br><span class="line"><span class="keyword">set</span>.add(b)</span><br><span class="line"><span class="keyword">set</span> // Set &#123;<span class="literal">NaN</span>&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> set1 = <span class="keyword">new</span> <span class="built_in">Set</span>()</span><br><span class="line">set1.add(<span class="number">5</span>)</span><br><span class="line">set1.add(<span class="string">'5'</span>)</span><br><span class="line"><span class="built_in">console</span>.log([...set1]) <span class="comment">// [5, "5"]</span></span><br></pre></td></tr></table></figure><p>Set 实例属性</p><p>constructor： 构造函数</p><p>size：元素数量</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="keyword">set</span> = new Set([1, 2, 3, 2, 1])</span><br><span class="line"></span><br><span class="line">console.log(<span class="keyword">set</span>.length) // undefined</span><br><span class="line">console.log(<span class="keyword">set</span>.size) // 3</span><br></pre></td></tr></table></figure><p>Set 实例方法</p><p>操作方法<br>add(value)：新增，相当于 array 里的 push</p><p>delete(value)：存在即删除集合中 value</p><p>has(value)：判断集合中是否存在 value</p><p>clear()：清空集合</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="keyword">set</span> = new Set()</span><br><span class="line"><span class="keyword">set</span></span><br><span class="line">  .add(1)</span><br><span class="line">  .add(2)</span><br><span class="line">  .add(1)</span><br><span class="line"></span><br><span class="line"><span class="keyword">set</span>.has(1) // true</span><br><span class="line"><span class="keyword">set</span>.has(3) // false</span><br><span class="line"><span class="keyword">set</span>.delete(1)</span><br><span class="line"><span class="keyword">set</span>.has(1) // false</span><br></pre></td></tr></table></figure><p>Array.from 方法可以将 Set 结构转为数组</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> items = <span class="keyword">new</span> <span class="built_in">Set</span>([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">2</span>])</span><br><span class="line"><span class="keyword">const</span> array = <span class="built_in">Array</span>.from(items)</span><br><span class="line"><span class="built_in">console</span>.log(array) <span class="comment">// [1, 2, 3]</span></span><br><span class="line"><span class="comment">// 或</span></span><br><span class="line"><span class="keyword">const</span> arr = [...items]</span><br><span class="line"><span class="built_in">console</span>.log(arr) <span class="comment">// [1, 2, 3]</span></span><br></pre></td></tr></table></figure><p>遍历方法（遍历顺序为插入顺序）<br>keys()：返回一个包含集合中所有键的迭代器</p><p>values()：返回一个包含集合中所有值得迭代器</p><p>entries()：返回一个包含 Set 对象中所有元素得键值对迭代器</p><p>forEach(callbackFn, thisArg)：用于对集合成员执行 callbackFn 操作，如果提供了 thisArg 参数，回调中的 this 会是这个参数，没有返回值</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="keyword">set</span> = new Set([1, 2, 3])</span><br><span class="line">console.log(<span class="keyword">set</span>.keys()) // SetIterator &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">set</span>.values()) // SetIterator &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">set</span>.entries()) // SetIterator &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> item <span class="keyword">of</span> <span class="keyword">set</span>.keys()) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(item)</span><br><span class="line">&#125; <span class="comment">// 1 2 3</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> item <span class="keyword">of</span> <span class="keyword">set</span>.entries()) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(item)</span><br><span class="line">&#125; <span class="comment">// [1, 1][2, 2] [3, 3]</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">set</span>.forEach((value, key) =&gt; &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(key + <span class="string">' : '</span> + value)</span><br><span class="line">&#125;) <span class="comment">// 1 : 1 2 : 2 3 : 3</span></span><br><span class="line"><span class="built_in">console</span>.log([...set]) <span class="comment">// [1, 2, 3]</span></span><br></pre></td></tr></table></figure><p>Set 可默认遍历，默认迭代器生成函数是 values() 方法</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Set</span>.prototype[<span class="built_in">Symbol</span>.iterator] === <span class="built_in">Set</span>.prototype.values <span class="comment">// true</span></span><br></pre></td></tr></table></figure><p>所以， Set 可以使用 map、filter 方法</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="keyword">set</span> = new Set([1, 2, 3])</span><br><span class="line"><span class="keyword">set</span> = new Set([...<span class="keyword">set</span>].map(item =&gt; item \* 2))</span><br><span class="line">console.log([...<span class="keyword">set</span>]) // [2, 4, 6]</span><br><span class="line"></span><br><span class="line"><span class="keyword">set</span> = new Set([...<span class="keyword">set</span>].filter(item =&gt; (item &gt;= 4)))</span><br><span class="line">console.log([...<span class="keyword">set</span>]) //[4, 6]</span><br></pre></td></tr></table></figure><p>因此，Set 很容易实现交集（Intersect）、并集（Union）、差集（Difference）</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> set1 = <span class="keyword">new</span> <span class="built_in">Set</span>([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>])</span><br><span class="line"><span class="keyword">let</span> set2 = <span class="keyword">new</span> <span class="built_in">Set</span>([<span class="number">4</span>, <span class="number">3</span>, <span class="number">2</span>])</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> intersect = <span class="keyword">new</span> <span class="built_in">Set</span>([...set1].filter(<span class="function"><span class="params">value</span> =&gt;</span> set2.has(value)))</span><br><span class="line"><span class="keyword">let</span> union = <span class="keyword">new</span> <span class="built_in">Set</span>([...set1, ...set2])</span><br><span class="line"><span class="keyword">let</span> difference = <span class="keyword">new</span> <span class="built_in">Set</span>([...set1].filter(<span class="function"><span class="params">value</span> =&gt;</span> !set2.has(value)))</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(intersect) <span class="comment">// Set &#123;2, 3&#125;</span></span><br><span class="line"><span class="built_in">console</span>.log(union) <span class="comment">// Set &#123;1, 2, 3, 4&#125;</span></span><br><span class="line"><span class="built_in">console</span>.log(difference) <span class="comment">// Set &#123;1&#125;</span></span><br></pre></td></tr></table></figure><h3 id="WeakSet"><a href="#WeakSet" class="headerlink" title="WeakSet"></a>WeakSet</h3><p>WeakSet 对象允许你将弱引用对象储存在一个集合中</p><p>WeakSet 与 Set 的区别：</p><p>WeakSet 只能储存对象引用，不能存放值，而 Set 对象都可以<br>WeakSet 对象中储存的对象值都是被弱引用的，即垃圾回收机制不考虑 WeakSet 对该对象的应用，如果没有其他的变量或属性引用这个对象值，则这个对象将会被垃圾回收掉（不考虑该对象还存在于 WeakSet 中），所以，WeakSet 对象里有多少个成员元素，取决于垃圾回收机制有没有运行，运行前后成员个数可能不一致，遍历结束之后，有的成员可能取不到了（被垃圾回收了），WeakSet 对象是无法被遍历的（ES6 规定 WeakSet 不可遍历），也没有办法拿到它包含的所有元素<br>属性：</p><p>constructor：构造函数，任何一个具有 Iterable 接口的对象，都可以作参数</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> arr = [[<span class="number">1</span>, <span class="number">2</span>], [<span class="number">3</span>, <span class="number">4</span>]]</span><br><span class="line"><span class="keyword">const</span> weakset = <span class="keyword">new</span> <span class="built_in">WeakSet</span>(arr)</span><br><span class="line"><span class="built_in">console</span>.log(weakset)</span><br></pre></td></tr></table></figure><p>方法：</p><p>add(value)：在 WeakSet 对象中添加一个元素 value<br>has(value)：判断 WeakSet 对象中是否包含 value<br>delete(value)：删除元素 value<br>clear()：清空所有元素，<strong>注意该方法已废弃</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> ws = <span class="keyword">new</span> <span class="built_in">WeakSet</span>()</span><br><span class="line"><span class="keyword">var</span> obj = &#123;&#125;</span><br><span class="line"><span class="keyword">var</span> foo = &#123;&#125;</span><br><span class="line"></span><br><span class="line">ws.add(<span class="built_in">window</span>)</span><br><span class="line">ws.add(obj)</span><br><span class="line"></span><br><span class="line">ws.has(<span class="built_in">window</span>) <span class="comment">// true</span></span><br><span class="line">ws.has(foo) <span class="comment">// false</span></span><br><span class="line"></span><br><span class="line">ws.delete(<span class="built_in">window</span>) <span class="comment">// true</span></span><br><span class="line">ws.has(<span class="built_in">window</span>) <span class="comment">// false</span></span><br></pre></td></tr></table></figure><h3 id="字典（Map）"><a href="#字典（Map）" class="headerlink" title="字典（Map）"></a>字典（Map）</h3><p>集合 与 字典 的区别：<br>共同点：集合、字典 可以储存不重复的值<br>不同点：集合 是以 [value, value]的形式储存元素，字典 是以 [key, value] 的形式储存</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> m = <span class="keyword">new</span> <span class="built_in">Map</span>()</span><br><span class="line"><span class="keyword">const</span> o = &#123; <span class="attr">p</span>: <span class="string">'haha'</span> &#125;</span><br><span class="line">m.set(o, <span class="string">'content'</span>)</span><br><span class="line">m.get(o) <span class="comment">// content</span></span><br><span class="line"></span><br><span class="line">m.has(o) <span class="comment">// true</span></span><br><span class="line">m.delete(o) <span class="comment">// true</span></span><br><span class="line">m.has(o) <span class="comment">// false</span></span><br></pre></td></tr></table></figure><p>任何具有 Iterator 接口、且每个成员都是一个双元素的数组的数据结构都可以当作 Map 构造函数的参数，例如：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">set</span> = new Set([['foo', 1], ['bar', 2]])</span><br><span class="line">const m1 = new Map(<span class="keyword">set</span>)</span><br><span class="line">m1.<span class="keyword">get</span>('foo') // 1</span><br><span class="line"></span><br><span class="line">const m2 = new Map([['baz', 3]])</span><br><span class="line">const m3 = new Map(m2)</span><br><span class="line">m3.<span class="keyword">get</span>('baz') // 3</span><br></pre></td></tr></table></figure><p>如果读取一个未知的键，则返回 undefined。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> <span class="built_in">Map</span>().get(<span class="string">'asfddfsasadf'</span>)</span><br><span class="line"><span class="comment">// undefined</span></span><br></pre></td></tr></table></figure><p>注意，只有对同一个对象的引用，Map 结构才将其视为同一个键。这一点要非常小心。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> map = <span class="keyword">new</span> <span class="built_in">Map</span>()</span><br><span class="line"></span><br><span class="line">map.set([<span class="string">'a'</span>], <span class="number">555</span>)</span><br><span class="line">map.get([<span class="string">'a'</span>]) <span class="comment">// undefined</span></span><br></pre></td></tr></table></figure><p>上面代码的 set 和 get 方法，表面是针对同一个键，但实际上这是两个值，内存地址是不一样的，因此 get 方法无法读取该键，返回 undefined。</p><p>由上可知，Map 的键实际上是跟内存地址绑定的，只要内存地址不一样，就视为两个键。这就解决了同名属性碰撞（clash）的问题，我们扩展别人的库的时候，如果使用对象作为键名，就不用担心自己的属性与原作者的属性同名。</p><p>如果 Map 的键是一个简单类型的值（数字、字符串、布尔值），则只要两个值严格相等，Map 将其视为一个键，比如 0 和-0 就是一个键，布尔值 true 和字符串 true 则是两个不同的键。另外，undefined 和 null 也是两个不同的键。虽然 NaN 不严格相等于自身，但 Map 将其视为同一个键。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> map = <span class="keyword">new</span> <span class="built_in">Map</span>()</span><br><span class="line"></span><br><span class="line">map.set(<span class="number">-0</span>, <span class="number">123</span>)</span><br><span class="line">map.get(+<span class="number">0</span>) <span class="comment">// 123</span></span><br><span class="line"></span><br><span class="line">map.set(<span class="literal">true</span>, <span class="number">1</span>)</span><br><span class="line">map.set(<span class="string">'true'</span>, <span class="number">2</span>)</span><br><span class="line">map.get(<span class="literal">true</span>) <span class="comment">// 1</span></span><br><span class="line"></span><br><span class="line">map.set(<span class="literal">undefined</span>, <span class="number">3</span>)</span><br><span class="line">map.set(<span class="literal">null</span>, <span class="number">4</span>)</span><br><span class="line">map.get(<span class="literal">undefined</span>) <span class="comment">// 3</span></span><br><span class="line"></span><br><span class="line">map.set(<span class="literal">NaN</span>, <span class="number">123</span>)</span><br><span class="line">map.get(<span class="literal">NaN</span>) <span class="comment">// 123</span></span><br></pre></td></tr></table></figure><p>Map 的属性及方法</p><p>属性：</p><p>constructor：构造函数</p><p>size：返回字典中所包含的元素个数</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> map = <span class="keyword">new</span> <span class="built_in">Map</span>([[<span class="string">'name'</span>, <span class="string">'An'</span>], [<span class="string">'des'</span>, <span class="string">'JS'</span>]])</span><br><span class="line"></span><br><span class="line">map.size <span class="comment">// 2</span></span><br></pre></td></tr></table></figure><p>操作方法：</p><p>set(key, value)：向字典中添加新元素<br>get(key)：通过键查找特定的数值并返回<br>has(key)：判断字典中是否存在键 key<br>delete(key)：通过键 key 从字典中移除对应的数据<br>clear()：将这个字典中的所有元素删除<br>遍历方法</p><p>Keys()：将字典中包含的所有键名以迭代器形式返回<br>values()：将字典中包含的所有数值以迭代器形式返回<br>entries()：返回所有成员的迭代器<br>forEach()：遍历字典的所有成员</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> map = <span class="keyword">new</span> <span class="built_in">Map</span>([[<span class="string">'name'</span>, <span class="string">'An'</span>], [<span class="string">'des'</span>, <span class="string">'JS'</span>]])</span><br><span class="line"><span class="built_in">console</span>.log(map.entries()) <span class="comment">// MapIterator &#123;"name" =&gt; "An", "des" =&gt; "JS"&#125;</span></span><br><span class="line"><span class="built_in">console</span>.log(map.keys()) <span class="comment">// MapIterator &#123;"name", "des"&#125;</span></span><br></pre></td></tr></table></figure><p>Map 结构的默认遍历器接口（Symbol.iterator 属性），就是 entries 方法。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">map[<span class="built_in">Symbol</span>.iterator] === map.entries</span><br><span class="line"><span class="comment">// true</span></span><br></pre></td></tr></table></figure><p>Map 结构转为数组结构，比较快速的方法是使用扩展运算符（…）。</p><p>对于 forEach ，看一个例子</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> reporter = &#123;</span><br><span class="line">  report: <span class="function"><span class="keyword">function</span>(<span class="params">key, value</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'Key: %s, Value: %s'</span>, key, value)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> map = <span class="keyword">new</span> <span class="built_in">Map</span>([[<span class="string">'name'</span>, <span class="string">'An'</span>], [<span class="string">'des'</span>, <span class="string">'JS'</span>]])</span><br><span class="line">map.forEach(<span class="function"><span class="keyword">function</span>(<span class="params">value, key, map</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.report(key, value)</span><br><span class="line">&#125;, reporter)</span><br><span class="line"><span class="comment">// Key: name, Value: An</span></span><br><span class="line"><span class="comment">// Key: des, Value: JS</span></span><br></pre></td></tr></table></figure><p>在这个例子中， forEach 方法的回调函数的 this，就指向 reporter</p><p><strong>与其他数据结构的相互转换</strong></p><p>Map 转 Array</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> map = <span class="keyword">new</span> <span class="built_in">Map</span>([[<span class="number">1</span>, <span class="number">1</span>], [<span class="number">2</span>, <span class="number">2</span>], [<span class="number">3</span>, <span class="number">3</span>]])</span><br><span class="line"><span class="built_in">console</span>.log([...map]) <span class="comment">// [[1, 1], [2, 2], [3, 3]]</span></span><br></pre></td></tr></table></figure><p>Array 转 Map</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> map = <span class="keyword">new</span> <span class="built_in">Map</span>([[<span class="number">1</span>, <span class="number">1</span>], [<span class="number">2</span>, <span class="number">2</span>], [<span class="number">3</span>, <span class="number">3</span>]])</span><br><span class="line"><span class="built_in">console</span>.log(map) <span class="comment">// Map &#123;1 =&gt; 1, 2 =&gt; 2, 3 =&gt; 3&#125;</span></span><br></pre></td></tr></table></figure><p>Map 转 Object</p><p>因为 Object 的键名都为字符串，而 Map 的键名为对象，所以转换的时候会把非字符串键名转换为字符串键名。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">mapToObj</span>(<span class="params">map</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> obj = <span class="built_in">Object</span>.create(<span class="literal">null</span>)</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> [key, value] <span class="keyword">of</span> map) &#123;</span><br><span class="line">    obj[key] = value</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> obj</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> map = <span class="keyword">new</span> <span class="built_in">Map</span>().set(<span class="string">'name'</span>, <span class="string">'An'</span>).set(<span class="string">'des'</span>, <span class="string">'JS'</span>)</span><br><span class="line">mapToObj(map) <span class="comment">// &#123;name: "An", des: "JS"&#125;</span></span><br></pre></td></tr></table></figure><p>Object 转 Map</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">objToMap</span>(<span class="params">obj</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> map = <span class="keyword">new</span> <span class="built_in">Map</span>()</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> key <span class="keyword">of</span> <span class="built_in">Object</span>.keys(obj)) &#123;</span><br><span class="line">    map.set(key, obj[key])</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> map</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">objToMap(&#123; <span class="attr">name</span>: <span class="string">'An'</span>, <span class="attr">des</span>: <span class="string">'JS'</span> &#125;) <span class="comment">// Map &#123;"name" =&gt; "An", "des" =&gt; "JS"&#125;</span></span><br></pre></td></tr></table></figure><p>Map 转 JSON</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">mapToJson</span>(<span class="params">map</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">JSON</span>.stringify([...map])</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> map = <span class="keyword">new</span> <span class="built_in">Map</span>().set(<span class="string">'name'</span>, <span class="string">'An'</span>).set(<span class="string">'des'</span>, <span class="string">'JS'</span>)</span><br><span class="line">mapToJson(map) <span class="comment">// [["name","An"],["des","JS"]]</span></span><br></pre></td></tr></table></figure><p>JSON 转 Map</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">jsonToStrMap</span>(<span class="params">jsonStr</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> objToMap(<span class="built_in">JSON</span>.parse(jsonStr))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">jsonToStrMap(<span class="string">'&#123;"name": "An", "des": "JS"&#125;'</span>) <span class="comment">// Map &#123;"name" =&gt; "An", "des" =&gt; "JS"&#125;</span></span><br></pre></td></tr></table></figure><h3 id="WeakMap"><a href="#WeakMap" class="headerlink" title="WeakMap"></a>WeakMap</h3><p>WeakMap 对象是一组键值对的集合，其中的键是弱引用对象，而值可以是任意。</p><p>注意，WeakMap 弱引用的只是键名，而不是键值。键值依然是正常引用。</p><p>WeakMap 中，每个键对自己所引用对象的引用都是弱引用，在没有其他引用和该键引用同一对象，这个对象将会被垃圾回收（相应的 key 则变成无效的），所以，WeakMap 的 key 是不可枚举的。</p><p>属性：</p><p>constructor：构造函数<br>方法：</p><p>has(key)：判断是否有 key 关联对象<br>get(key)：返回 key 关联对象（没有则则返回 undefined）<br>set(key)：设置一组 key 关联对象<br>delete(key)：移除 key 的关联对象</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> myElement = <span class="built_in">document</span>.getElementById(<span class="string">'logo'</span>)</span><br><span class="line"><span class="keyword">let</span> myWeakmap = <span class="keyword">new</span> <span class="built_in">WeakMap</span>()</span><br><span class="line"></span><br><span class="line">myWeakmap.set(myElement, &#123; <span class="attr">timesClicked</span>: <span class="number">0</span> &#125;)</span><br><span class="line"></span><br><span class="line">myElement.addEventListener(</span><br><span class="line">  <span class="string">'click'</span>,</span><br><span class="line">  <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> logoData = myWeakmap.get(myElement)</span><br><span class="line">    logoData.timesClicked++</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="literal">false</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p><strong>Set</strong><br>成员唯一、无序且不重复<br>[value, value]，键值与键名是一致的（或者说只有键值，没有键名）<br>可以遍历，方法有：add、delete、has<br><strong>WeakSet</strong><br>成员都是对象<br>成员都是弱引用，可以被垃圾回收机制回收，可以用来保存 DOM 节点，不容易造成内存泄漏<br>不能遍历，方法有 add、delete、has<br><strong>Map</strong><br>本质上是键值对的集合，类似集合<br>可以遍历，方法很多可以跟各种数据格式转换<br><strong>WeakMap</strong><br>只接受对象作为键名（null 除外），不接受其他类型的值作为键名<br>键名是弱引用，键值可以是任意的，键名所指向的对象可以被垃圾回收，此时键名是无效的<br>不能遍历，方法有 get、set、has、delete</p><h3 id="扩展：Object-与-Set、Map"><a href="#扩展：Object-与-Set、Map" class="headerlink" title="扩展：Object 与 Set、Map"></a>扩展：Object 与 Set、Map</h3><p>Object 与 Set</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Object</span></span><br><span class="line"><span class="keyword">const</span> properties1 = &#123;</span><br><span class="line">  width: <span class="number">1</span>,</span><br><span class="line">  height: <span class="number">1</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(properties1[<span class="string">'width'</span>] ? <span class="literal">true</span> : <span class="literal">false</span>) <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Set</span></span><br><span class="line"><span class="keyword">const</span> properties2 = <span class="keyword">new</span> <span class="built_in">Set</span>()</span><br><span class="line">properties2.add(<span class="string">'width'</span>)</span><br><span class="line">properties2.add(<span class="string">'height'</span>)</span><br><span class="line"><span class="built_in">console</span>.log(properties2.has(<span class="string">'width'</span>)) <span class="comment">// true</span></span><br></pre></td></tr></table></figure><p>Object 与 Map</p><p>JS 中的对象（Object），本质上是键值对的集合（hash 结构）</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> data = &#123;&#125;</span><br><span class="line"><span class="keyword">const</span> element = <span class="built_in">document</span>.getElementsByClassName(<span class="string">'App'</span>)</span><br><span class="line"></span><br><span class="line">data[element] = <span class="string">'metadata'</span></span><br><span class="line"><span class="built_in">console</span>.log(data[<span class="string">'[object HTMLCollection]'</span>]) <span class="comment">// "metadata"</span></span><br></pre></td></tr></table></figure><p>但当以一个 DOM 节点作为对象 data 的键，对象会被自动转化为字符串[Object HTMLCollection]，所以说，Object 结构提供了 <strong>字符串-值</strong> 对应，Map 则提供了 <strong>值-值</strong>的对应</p><hr><h2 id="Vue-的数据双向绑定原理"><a href="#Vue-的数据双向绑定原理" class="headerlink" title="Vue 的数据双向绑定原理"></a>Vue 的数据双向绑定原理</h2><hr>]]></content>
    
    <summary type="html">
    
      &lt;pre&gt;&lt;code&gt;Set、Map、WeakSet 和 WeakMap 的区别&lt;/code&gt;&lt;/pre&gt;
    
    </summary>
    
      <category term="面试题" scheme="https://cassielee.top/categories/%E9%9D%A2%E8%AF%95%E9%A2%98/"/>
    
    
      <category term="面试题" scheme="https://cassielee.top/tags/%E9%9D%A2%E8%AF%95%E9%A2%98/"/>
    
  </entry>
  
</feed>
