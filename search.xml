<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[hkzf项目总结]]></title>
    <url>%2F2019%2F07%2F28%2Fhkzf%E9%A1%B9%E7%9B%AE%E6%80%BB%E7%BB%93%2F</url>
    <content type="text"></content>
      <tags>
        <tag>Project</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JS面试题]]></title>
    <url>%2F2019%2F07%2F25%2FJS%E9%9D%A2%E8%AF%95%E9%A2%98%2F</url>
    <content type="text"></content>
  </entry>
  <entry>
    <title><![CDATA[ES6面试题]]></title>
    <url>%2F2019%2F07%2F19%2F%E6%A8%A1%E6%9D%BF%2F</url>
    <content type="text"><![CDATA[ES面试题 面试题总结v-if 和 v-show 区别v-show指令仅仅控制元素的显示方式，将display:none属性在 block 和 none 来回切换v-if指令会控制这个 DOM 节点的存在与否当我们需要经常切换某个元素的显示/隐藏时，使用 v-show 会更加节省性能;当只需要一次显示或隐藏时，使用 v-if Vue 的数据双向绑定原理]]></content>
      <categories>
        <category>面试题</category>
      </categories>
      <tags>
        <tag>面试题</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Vue面试题总结]]></title>
    <url>%2F2019%2F07%2F19%2F%E9%9D%A2%E8%AF%95%E9%A2%98%20-%20Vue%2F</url>
    <content type="text"><![CDATA[Vue面试题 面试题总结v-if 和 v-show 区别v-show指令仅仅控制元素的显示方式，将display:none属性在 block 和 none 来回切换v-if指令会控制这个 DOM 节点的存在与否当我们需要经常切换某个元素的显示/隐藏时，使用 v-show 会更加节省性能;当只需要一次显示或隐藏时，使用 v-if Vue 的数据双向绑定原理采用数据劫持结合发布者-订阅者模式的方式，通过 Object.defineProperty()来劫持各个属性的 setter，getter,在数据变动时发布消息给订阅者，触发响应的监听回调。 Vue 组件间是怎么通讯的 常见指令 怎么定义组件 Vue 路由是怎么做的（路由的原理） 怎么请求数据 谈谈组件化和模块化的区别、模块化：是从代码逻辑的角度进行划分的，方便代码分层开发，保证每个功能模块的职能单一组件化：是从 UI 的角度进行划分的，前端的组件化，方便 UI 组件的复用 Vue 全家桶 Vuex 的使用和五个核心]]></content>
      <categories>
        <category>面试题</category>
      </categories>
      <tags>
        <tag>面试题</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[面试题总结]]></title>
    <url>%2F2019%2F07%2F19%2F%E9%9D%A2%E8%AF%95%E9%A2%98%2F</url>
    <content type="text"><![CDATA[根据日常总结的知识点进行分析 面试题总结 写 React / Vue 项目时为什么要在列表组件中写 key，其作用是什么？解析：（Vue/React）key 的作用是为了在 diff 算法执行时更快的找到对应的节点，提高 diff 速度 (Vue)key 的作用是为了在数据变化时强制更新组件，以避免“原地复用”带来的副作用。 从用户刷新网页开始，一次 js 请求一般情况下有哪些地方会有缓存处理？解析：DNS 缓存、CDN 缓存、浏览器缓存、服务器缓存 DNS 缓存 即 （Domain Name System 域名系统）为了增加访问效率， 计算机有域名缓存机制。即当访问过某个网站并得到其 IP 后，会将其域名和 IP 缓存下来， 下一次访问的时候，就不需要再请求域名服务器获取 IP, 直接使用缓存中的 IP，提高了响应的速度。 当前缓存时间是有有效时间的，当过了有效时间后， 还是需要先请求域名解析。 扩： DNS 预解析 因为在调用当前页面所在域名外的域名文件时，会遇到请求延时非常严重的情况。我们可以使用 DNS 预解析。 用 meta 信息来告知浏览器，当前页面要做 DNS 预解析： 1&lt;meta http-equiv="x-dns-prefetch-control" content="on" /&gt; 在页面 header 中使用 link 标签来强制对 DNS 预解析 1&lt;link rel="dns-prefetch" href="http://bdimg.share.baidu.com" /&gt; CDN 即 （Content Delivery NetWork） 内容分发网络CDN 是构建在网络之上的内容分发网络，依靠部署在各地的边缘服务器，通过中心平台的负载均衡、内容分发、调度等功能模块，使用户就近获取所需内容，降低网络拥塞，提高用户访问响应速度和命中率。CDN 的关键技术主要有内容存储和分发技术。 通俗解释：就是当我们发送一个 web 请求时，会先经过它一道手，然后它帮我们计算路径，去哪得到这些东东（representations）的路径短且快。这个是网站管理员部署的，所以他们也可以将大家经常访问的 representations 放在 CDN 里，这样，就响应就更快了。 浏览器缓存通过浏览器实现 HTTP 缓存。 Expires添加 Expires 头能有效的利用浏览器的缓存能力来改善页面的性能，能在后续的页面中有效避免很多不必要的 Http 请求，WEB 服务器使用 Expires 头来告诉 Web 客户端它可以使用一个组件的当前副本，直到指定的时间为止。 例如：Expires：Thu，15 Apr 2010 20：00：00 GMT; 他告诉浏览器缓存有效性持续到 2010 年 4 月 15 日为止，在这个时间之内相同的请求使用缓存，这个时间之外使用 http 请求。 Cathe-Control使用 max-age 指定组件被缓存多久，从请求开始在 max-age 时间内浏览器使用缓存，之外的使用请求，这样就可以消除 Expires 的限制. 例如：Cathe-Control：max-age=315360000 服务器缓存服务器缓存一般指缓存服务器缓存指的是将需要频繁访问的网络内容存放在离用户较近、访问速度更快的系统中，以提高内容访问速度的一种技术。缓存服务器就是存放频繁访问内容的服务器。]]></content>
      <categories>
        <category>面试题</category>
      </categories>
      <tags>
        <tag>面试题</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hello World]]></title>
    <url>%2F2019%2F07%2F16%2Fhello-world%2F</url>
    <content type="text"><![CDATA[Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new "My New Post" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment]]></content>
  </entry>
  <entry>
    <title><![CDATA[React的基本使用]]></title>
    <url>%2F2018%2F07%2F19%2FReact%E7%9A%84%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8%2F</url>
    <content type="text"><![CDATA[react 是什么 React 是一个 JS 库，用来构建用户界面（写 HTML，构建 web 应用） 从 MVC 的角度来看，相当于 视图层 V（View） 的内容。 react 的特点 声明式： 我们只需要描述页面长什么样子就可以了，React 负责更新页面 基于组件（组件化） 学习一次，随处使用（Web 、 安卓/ios、vr …） React 的基本使用 安装：npm i react react-dom 引入 react 和 react-dom 两个 js 文件（注意：引入顺序，react 在前，react-dom 在后） 创建 React 元素 const h1 = React.createElement(&#39;h1&#39;, null, &#39;子节点&#39;) 渲染创建好的 React 元素，到页面中 ReactDOM.render(h1, document.getElementById(&#39;root&#39;)) React.createElement() 方法的说明 作用：创建 react 元素的 12345678910111213141516171819202122// 创建React元素// 第一个参数：表示要创建什么元素，就是 HTML 标签名称// 第二个参数：表示元素自身属性，如果没有就传 null// 如果要指定元素自身的属性，就传递一个对象（&#123;&#125;）// 1 class ==&gt; className// 2 for ==&gt; htmlFor// 第三个及其以后的参数：表示元素的子节点（文本、元素节点）// 如果是文本节点，就直接传递 字符串。// 如果是元素节点，就继续调用 React.createElement() 方法，创建新的React元素节点//// const h1 = React.createElement('div', null, 'Hello React')const h1 = React.createElement( 'h1', &#123; id: 'title', className: 'cls', htmlFor: 'd' &#125;, 'Hello React', 'test 文本节点', React.createElement('span', null, '这是一个span')) React 脚手架初始化项目的步骤 命令：npx create-react-app 项目名称 比如：npx create-react-app my-app npx 命令：简化使用脚手架初始化项目的流程 不使用 npx：1 先全局安装脚手架的包 2 使用脚手架包提供的命令来初始化项目 使用 npx：不需要再全局安装脚手架的包，直接就可以初始化项目 如何启动项目？进入项目根目录然后，执行以下命令 yarn start npm start 在脚手架中使用 react 导入 import React from &#39;react&#39; import ReactDOM from &#39;react-dom&#39; JSX 为什么要学习 JSX ？ 因为 createElement 形式，太繁琐，不直观，书写效率不高，所以，我们不想用这种方式。 JSX 特点：不反锁，直观，书写效率高 JSX 是什么？ JavaScript XML（HTML），也就是在 JS 中书写 HTMl 格式的代码 JSX 的基本使用 导入 react 和 react-dom 使用 JSX 语法创建 React 元素 JSX 就跟写 HTML 一样 渲染创建好的 React 元素 JSX 语法的注意点 JSX 元素的属性名推荐使用：驼峰命名法 class ===&gt; className 如果元素没有子节点，可以使用 单标签 方式来结束 比如：&lt;div /&gt; 推荐使用 () 来包裹 JSX，从而避免 JS 中自动插入分号机制 在 JSX 中使用 JS 表达式（数据） 语法：使用 {} ，就可以在 JSX 中使用 JS 中的数据了 &lt;div&gt;Hello {name + &#39;666&#39;}&lt;/div&gt; 原则：可以在 {} 中使用任何的 JS 表达式。 注意：不能在 {} 中，使用 语句！ 比如： if/for/switch … 注意：不能在 {} 中使用对象，除了 style 属性以外！！！ JSX 自身也是一个 JS 表达式，所以，可以在 {} 中继续使用 JSX ！！！ React 的条件渲染 使用 if/esle 来实现 123456789const loadData = () =&gt; &#123; if (isLoading) &#123; return &lt;div&gt;loading...&lt;/div&gt; &#125; return &lt;div&gt;加载完成后的列表结构&lt;/div&gt;&#125;const h1 = &lt;div&gt;&#123;loadData()&#125;&lt;/div&gt; 使用三元表达式 123const loadData = () =&gt; &#123; return isLoading ? &lt;div&gt;loading...&lt;/div&gt; : &lt;div&gt;加载完成后的列表结构&lt;/div&gt;&#125; 逻辑运算符 &amp;&amp; 123const loadData = () =&gt; &#123; return isLoading &amp;&amp; &lt;div&gt;loading...&lt;/div&gt;&#125; React 中的列表渲染 使用数组的 map 方法来进行列表渲染 需要给被遍历生成的元素添加 key 属性，key 应该是唯一的。尽量避免使用 index 作为索引号。 剩下的就是 JS 中 map 方法的使用了。 12345&lt;ul&gt; &#123;songs.map(item =&gt; ( &lt;li key=&#123;item.id&#125;&gt;&#123;item.name&#125;&lt;/li&gt; ))&#125;&lt;/ul&gt; React 中给 JSX 添加样式 行内样式（style） 不推荐 12345const h1 = ( &lt;h1 style=&#123;&#123; color: 'red', fontSize: 30, backgroundColor: 'hotpink' &#125;&#125;&gt; 我变大了 &lt;/h1&gt;) className 类名 — 推荐！！！ 1const h1 = &lt;h1 className="pink"&gt;我变大了&lt;/h1&gt; 案例1234567;[ &#123; user: '张三', content: '哈哈，沙发' &#125;, &#123; user: '张三2', content: '哈哈，板凳' &#125;, &#123; user: '张三3', content: '哈哈，凉席' &#125;, &#123; user: '张三4', content: '哈哈，砖头' &#125;, &#123; user: '张三5', content: '哈哈，楼下山炮' &#125;]]]></content>
      <categories>
        <category>React</category>
      </categories>
      <tags>
        <tag>React</tag>
      </tags>
  </entry>
</search>
