<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[hexo常用命令]]></title>
    <url>%2F2020%2F10%2F19%2Fhexo%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4%2F</url>
    <content type="text"><![CDATA[hexo常用命令 一、安装、升级123npm install hexo -g #安装 npm update hexo -g #升级 hexo init #初始化 二、简写12345hexo n "我的博客" == hexo new "我的博客" #新建文章hexo p == hexo publishhexo g == hexo generate#生成hexo s == hexo server #启动服务预览hexo d == hexo deploy#部署 三、服务器1234567hexo server #Hexo 会监视文件变动并自动更新，您无须重启服务器。hexo server -s #静态模式hexo server -p 5000 #更改端口hexo server -i 192.168.1.1 #自定义 IPhexo clean #清除缓存 网页正常情况下可以忽略此条命令hexo g #生成静态网页hexo d #开始部署 四、监视文件变动12hexo generate #使用 Hexo 生成静态文件快速而且简单hexo generate --watch #监视文件变动 五、完成后部署两个命令的作用是相同的 1234hexo generate --deployhexo deploy --generatehexo deploy -ghexo server -g 六、草稿1hexo publish [layout] &lt;title&gt; 七、模板12345678hexo new "postName" #新建文章hexo new page "pageName" #新建页面hexo generate #生成静态页面至public目录hexo server #开启预览访问端口（默认端口4000，'ctrl + c'关闭server）hexo deploy #将.deploy目录部署到GitHubhexo new [layout] &lt;title&gt;hexo new photo "My Gallery"hexo new "Hello World" --lang tw 八、推送到服务器上123hexo n #写文章hexo g #生成hexo d #部署 #可与hexo g合并为 hexo d -g 九、报错1、找不到 git 部署 ERROR Deployer not found: git 12解决方法npm install hexo-deployer-git --save 2、部署类型设置 git hexo 3.0 部署类型不再是github，_config.yml 中修改 123456# Deployment## Docs: http://hexo.io/docs/deployment.htmldeploy: type: git repository: git@***.github.com:***/***.github.io.git branch: master]]></content>
      <categories>
        <category>hexo</category>
      </categories>
      <tags>
        <tag>hexo</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[powershell禁止运行脚本报错问题]]></title>
    <url>%2F2020%2F10%2F19%2Fpowershell%E7%A6%81%E6%AD%A2%E8%BF%90%E8%A1%8C%E8%84%9A%E6%9C%AC%E6%8A%A5%E9%94%99%E9%97%AE%E9%A2%98%2F</url>
    <content type="text"><![CDATA[powershell禁止运行脚本报错问题，windows环境原因导致 报错信息 解决方案 win+X启动 windows PowerShell（管理员） 若要在本地计算机上运行您编写的未签名脚本和来自其他用户的签名脚本，请使用以下命令将计算机上的 执行策略更改为 RemoteSigned 执行：set-ExecutionPolicy RemoteSigned 查看执行策略：get-ExecutionPolicy]]></content>
      <categories>
        <category>Tip</category>
      </categories>
      <tags>
        <tag>tip</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JS]]></title>
    <url>%2F2019%2F07%2F25%2FJS%E6%80%BB%E7%BB%93%2F</url>
    <content type="text"><![CDATA[根据日常总结的知识点进行分析 调用 new 的 4 件事 创建一个新对象 将对象里面的 this 指向这个新的对象 将新对象连接到构造函数的原型 返回这个对象 闭包函数 A 内部有一个函数 B，函数 B 可以访问带函数 A 中的变量，那么函数 B 就是闭包 私有变量 案例：沙箱]]></content>
      <categories>
        <category>JS</category>
      </categories>
      <tags>
        <tag>JS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Vue面试题总结]]></title>
    <url>%2F2019%2F07%2F19%2F%E9%9D%A2%E8%AF%95%E9%A2%98%20-%20Vue%2F</url>
    <content type="text"><![CDATA[Vue面试题 v-if 和 v-show 区别v-show指令仅仅控制元素的显示方式，将display:none属性在 block 和 none 来回切换v-if指令会控制这个 DOM 节点的存在与否当我们需要经常切换某个元素的显示/隐藏时，使用 v-show 会更加节省性能;当只需要一次显示或隐藏时，使用 v-if Vue 的数据双向绑定原理采用数据劫持结合发布者-订阅者模式的方式，通过 Object.defineProperty()来劫持各个属性的 setter，getter,在数据变动时发布消息给订阅者，触发响应的监听回调。 Vue 组件间是怎么通讯的 常见指令 怎么定义组件 Vue 路由是怎么做的（路由的原理） 怎么请求数据 谈谈组件化和模块化的区别、模块化：是从代码逻辑的角度进行划分的，方便代码分层开发，保证每个功能模块的职能单一组件化：是从 UI 的角度进行划分的，前端的组件化，方便 UI 组件的复用 Vue 全家桶 Vuex 的使用和五个核心]]></content>
      <categories>
        <category>面试题</category>
      </categories>
      <tags>
        <tag>面试题</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[面试题总结]]></title>
    <url>%2F2019%2F07%2F19%2F%E9%9D%A2%E8%AF%95%E9%A2%98%2F</url>
    <content type="text"><![CDATA[根据日常总结的知识点进行分析 写 React / Vue 项目时为什么要在列表组件中写 key，其作用是什么解析：（Vue/React）key 的作用是为了在 diff 算法执行时更快的找到对应的节点，提高 diff 速度 (Vue)key 的作用是为了在数据变化时强制更新组件，以避免“原地复用”带来的副作用。 从用户刷新网页开始，一次 js 请求一般情况下有哪些地方会有缓存处理解析：DNS 缓存、CDN 缓存、浏览器缓存、服务器缓存 DNS 缓存 即 （Domain Name System 域名系统）为了增加访问效率， 计算机有域名缓存机制。即当访问过某个网站并得到其 IP 后，会将其域名和 IP 缓存下来， 下一次访问的时候，就不需要再请求域名服务器获取 IP, 直接使用缓存中的 IP，提高了响应的速度。 当前缓存时间是有有效时间的，当过了有效时间后， 还是需要先请求域名解析。 扩： DNS 预解析 因为在调用当前页面所在域名外的域名文件时，会遇到请求延时非常严重的情况。我们可以使用 DNS 预解析。 用 meta 信息来告知浏览器，当前页面要做 DNS 预解析： 1&lt;meta http-equiv="x-dns-prefetch-control" content="on" /&gt; 在页面 header 中使用 link 标签来强制对 DNS 预解析 1&lt;link rel="dns-prefetch" href="http://bdimg.share.baidu.com" /&gt; CDN 即 （Content Delivery NetWork） 内容分发网络CDN 是构建在网络之上的内容分发网络，依靠部署在各地的边缘服务器，通过中心平台的负载均衡、内容分发、调度等功能模块，使用户就近获取所需内容，降低网络拥塞，提高用户访问响应速度和命中率。CDN 的关键技术主要有内容存储和分发技术。 通俗解释：就是当我们发送一个 web 请求时，会先经过它一道手，然后它帮我们计算路径，去哪得到这些东东（representations）的路径短且快。这个是网站管理员部署的，所以他们也可以将大家经常访问的 representations 放在 CDN 里，这样，就响应就更快了。 浏览器缓存通过浏览器实现 HTTP 缓存。 Expires添加 Expires 头能有效的利用浏览器的缓存能力来改善页面的性能，能在后续的页面中有效避免很多不必要的 Http 请求，WEB 服务器使用 Expires 头来告诉 Web 客户端它可以使用一个组件的当前副本，直到指定的时间为止。 例如：Expires：Thu，15 Apr 2010 20：00：00 GMT; 他告诉浏览器缓存有效性持续到 2010 年 4 月 15 日为止，在这个时间之内相同的请求使用缓存，这个时间之外使用 http 请求。 Cathe-Control使用 max-age 指定组件被缓存多久，从请求开始在 max-age 时间内浏览器使用缓存，之外的使用请求，这样就可以消除 Expires 的限制. 例如：Cathe-Control：max-age=315360000 服务器缓存服务器缓存一般指缓存服务器缓存指的是将需要频繁访问的网络内容存放在离用户较近、访问速度更快的系统中，以提高内容访问速度的一种技术。缓存服务器就是存放频繁访问内容的服务器。 Javascript：history.go()和 history.back()的用法与区别go() 方法可加载历史列表中的某个具体的页面。该参数可以是数字，使用的是要访问的 URL 在 History 的 URL 列表中的相对位置。（-1 上一个页面，1 前进一个页面)。或一个字符串，字符串必须是局部或完整的 URL，该函数会去匹配字符串的第一个 URL。 go(-1):返回上一页，原页面表单中的内容会丢失；back():返回上一页，原页表表单中的内容会保留。 什么是防抖和节流？有什么区别？如何实现防抖(debounce)触发高频事件后 n 秒内函数只会执行一次，如果 n 秒内高频事件再次被触发，则重新计算时间(函数防抖: 任务频繁触发的情况下，只有任务触发的间隔超过指定间隔的时候，任务才会执行。) 思路：每次触发事件时都取消之前的延时调用方法 其实函数防抖的原理也非常地简单，通过闭包保存一个标记来保存 setTimeout 返回的值，每当用户输入的时候把前一个 setTimeout clear 掉，然后又创建一个新的 setTimeout，这样就能保证输入字符后的 interval 间隔内如果还有字符输入的话，就不会执行 fn 函数了。 12345678910111213141516function debounce(fn) &#123; let timeout = null // 创建一个标记用来存放定时器的返回值 return function() &#123; clearTimeout(timeout) // 每当用户输入的时候把前一个 setTimeout clear 掉 timeout = setTimeout(() =&gt; &#123; // 然后又创建一个新的 setTimeout, 这样就能保证输入字符后的 interval 间隔内如果还有字符输入的话，就不会执行 fn 函数 fn.apply(this, arguments) &#125;, 500) &#125;&#125;function sayHi() &#123; console.log('防抖成功')&#125;var inp = document.getElementById('inp')inp.addEventListener('input', debounce(sayHi)) // 防抖 节流(throttle)高频事件触发，但在 n 秒内只会执行一次，所以节流会稀释函数的执行频率(函数节流: 指定时间间隔内只会执行一次任务) 思路：每次触发事件时都判断当前是否有等待执行的延时函数 简单来说，函数的节流就是通过闭包保存一个标记（canRun = true），在函数的开头判断这个标记是否为 true，如果为 true 的话就继续执行函数，否则则 return 掉，判断完标记后立即把这个标记设为 false，然后把外部传入的函数的执行包在一个 setTimeout 中，最后在 setTimeout 执行完毕后再把标记设置为 true（这里很关键），表示可以执行下一次的循环了。当 setTimeout 还未执行的时候，canRun 这个标记始终为 false，在开头的判断中被 return 掉 1234567891011121314151617function throttle(fn) &#123; let canRun = true // 通过闭包保存一个标记 return function() &#123; if (!canRun) return // 在函数开头判断标记是否为true，不为true则return canRun = false // 立即设置为false setTimeout(() =&gt; &#123; // 将外部传入的函数的执行放在setTimeout中 fn.apply(this, arguments) // 最后在setTimeout执行完毕后再把标记设置为true(关键)表示可以执行下一次循环了。当定时器没有执行的时候标记永远是false，在开头被return掉 canRun = true &#125;, 500) &#125;&#125;function sayHi(e) &#123; console.log(e.target.innerWidth, e.target.innerHeight)&#125;window.addEventListener('resize', throttle(sayHi)) 总结：其实函数节流与函数防抖的原理非常简单，巧妙地使用 setTimeout 来存放待执行的函数，这样可以很方便的利用 clearTimeout 在合适的时机来清除待执行的函数。使用函数节流与函数防抖的目的，在开头的栗子中应该也能看得出来，就是为了节约计算机资源。]]></content>
      <categories>
        <category>面试题</category>
      </categories>
      <tags>
        <tag>面试题</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[js 的继承机制]]></title>
    <url>%2F2019%2F01%2F19%2Fjs%E7%BB%A7%E6%89%BF%E6%9C%BA%E5%88%B6%2F</url>
    <content type="text"><![CDATA[js 的继承机制 ES5 和 ES6 及继承机制ES5 继承机制在 js 万物皆对象，但事还是区分普通对象和函数对象，只有函数对象才有 prototype 属性，但所有对象都有__proto__属性 12function A() &#123;&#125;var B = new A() 那这里就得出几个公式： 123B.**proto**== A.prototype;B.constructor == A;a.prototype.constuctor = A; 那这是实现继承的基础； 也就是说 A.prototype 是 A 的原型对象，A 是构造函数，B 是 A 的实例，原型对象（A.prototype）是 构造函数（A）的一个实例。而此时 this 指向是指向实例。 明白这个关系实现继承就很简单了！看一下下面的代码 原型链继承通过重写子类的原型 等于 父类的一个实例，（父类的实例属相变成子类的原型属性） 1234567891011121314function father() &#123; this.faName = 'father'&#125;father.prototype.getfaName = function() &#123; console.log(this.faName)&#125;function child() &#123; this.chName = 'child'&#125;child.prototype = new father()child.prototype.constructor = childchild.prototype.getchName = function() &#123; console.log(this.chName)&#125; 组合继承 （比较常用，也有缺点）通过子类的原型对象指向父类实例的方式来实现继承，那我们不难发现原型链的形成是真正是靠__proto__ 而非 prototype，子类的实例可以访问父类原型上的方法，是因为子类实例通过__proto__与父类的原型对象有连接 1234567891011121314151617181920//先来个父类，带些属性function Super() &#123; this.flag = true&#125;//为了提高复用性，方法绑定在父类原型属性上Super.prototype.getFlag = function() &#123; return this.flag&#125;//来个子类function Sub() &#123; this.subFlag = false&#125;//实现继承Sub.prototype = new Super()//给子类添加子类特有的方法，注意顺序要在继承之后Sub.prototype.getSubFlag = function() &#123; return this.subFlag&#125;//构造实例var es5 = new Sub() 寄生组合继承 （业内比较提倡的方法）所谓寄生组合式继承，即通过借助构造函数来继承属性，通过原型链的混成形式来继承方法。 其背后的基本思路是：不必为了指定子类型的原型而调用超类型的构造函数，我们所需要的无非就是超类型原型的一个副本而已。本质上，就是使用寄生式继承来继承超类型的原型，然后再将结果指定给子类型的原型。 12345678910111213141516171819202122232425function inserit(son, father) &#123; var obj = Object.create(father.prototype) son.prototype = obj obj.constructor = son&#125;function SuperType(name, colors) &#123; this.name = name this.colors = colors&#125;SuperType.prototype.sayName = function() &#123; return this.name&#125;function SubType(job, name, color) &#123; SuperType.call(this, name, color) this.job = job&#125;//核心方法inserit(SubType, SuperType)SubType.prototype.sayjob = function() &#123; return this.job&#125;var instance = new SubType('doctor', 'John', ['red', 'green'])console.log(instance.sayjob(), instance.sayName()) //doctor,John [x] 原型链继承缺点：父类包含引用类型的属性，那么子类所有实例都会共享该属性（包含引用类型的原型属性会被实例共享），在创建子类实例时，不能向父类的构造函数传递参数[x] 组合继承的缺点：两次调用父类构造函数：（第一次是在创建子类原型的时候，第二次是在子类构造函数内部）子类继承父类的属性，一组在子类实例上，一组在子类原型上（在子类原型上创建不必要的多余的属性）（实例上的屏蔽原型上的同名属性）效率低[x] 组合继承的优点：只调用一次父类的构造函数,避免了在子类原型上创建不必要的，多余的属性，原型链保持不变ES5 的继承机制总结ES5 的继承机制简单来说就是：实质是先创造子类的实例对象 this，然后再将父类的方法添加到 this 上面（Parent.apply(this)） ES6 的继承机制1234567891011121314151617181920class Point &#123; constructor(x) &#123; this.x = 1 this.p = 2 &#125; print() &#123; return this.x &#125;&#125;Point.prototype.z = '4'class ColorPoint extends Point &#123; constructor(x) &#123; this.color = color // ReferenceError super(x, y) this.x = x // 正确 &#125; m() &#123; super.print() &#125;&#125; ES6 继承是通过 class、extends 关键字来实现继承 Point 是父类，ColorPoint 是子类 通过 class 新建子类 extends 继承父类的方式实现继承，方式比 ES5 简单的多。 constructorconstructor 方法是类的构造函数，是一个默认方法，通过 new 命令创建对象实例时，自动调用该方法。一个类必须有 constructor 方法，如果没有显式定义，一个默认的 consructor 方法会被默认添加。所以即使你没有添加构造函数，也是会有一个默认的构造函数的。一般 constructor 方法返回实例对象 this ，但是也可以指定 constructor 方法返回一个全新的对象，让返回的实例对象不是该类的实例。 1234567891011121314151617181920class Points &#123;constructor(x) &#123;this.x = 1;this.p = 2;&#125;print() &#123;return this.x;&#125;statc getname()&#123;return new.target.name;&#125;&#125;// 等同于：function Points(x) &#123;this.x = x;this.p = 2;&#125;Points.prototype.print = function() &#123;return '(' + this.x +')';&#125; 也就是说 constructor 就代表在父类上加属性，而在 class 对象加方法属性 等于在原型上的加。而这些属性方法 只有通过 new 出的实例 或者是 extends 继承出来的实例才可以获取到 所以我们可以得到 12new Points().__proto__.print() //可以调用到 Points 的 print 方法new Points().x = 1 //可以调用到 constructor 里面的 this.x=1 supersuper 既可以当做函数使用，也可以当做对象使用两种使用的时候完全不一样， 函数用时 : 在 constructor 中必须调用 super 方法，因为子类没有自己的 this 对象，而是继承父类的 this 对象，然后对其进行加工,而 super 就代表了父类的构造函数。super 虽然代表了父类 A 的构造函数，但是返回的是子类 B 的实例，即 super 内部的 this 指的是 B，因此 super() 在这里相当于 1A.prototype.constructor.call(this, props) 在 super() 执行时，它指向的是 子类 B 的构造函数，而不是父类 A 的构造函数。也就是说，super() 内部的 this 指向的是 B。所以在第一个 es6 的例子中子类的 this 指向的是自己。、 当做对象使用 ： 在普通方法中，指向父类的原型对象；在静态方法中，指向父类。 所以在子类的方法中 super.print();指向的是父类原型上的方法。 但是因为 super 的两种用法，所以 es6 规定在使用必须要明确使用方式，像单独 console.log(super) 就会报错。 static顾名思义是静态方法的意思，类相当于实例的原型， 所有在类中定义的方法， 都会被实例继承。 如果在一个方法前， 加上 static 关键字， 就表示该方法不会被实例继承， 而是直接通过类来调用， 这就称为“ 静态方法”。静态方法调用直接在类上进行，而在类的实例上不可被调用。静态方法通常用于创建 实用/工具 函数。 new.targetnew.target 属性允许你检测函数或构造方法是否通过是通过 new 运算符被调用的。在通过 new 运算符被初始化的函数或构造方法中，new.target 返回一个指向构造方法或函数的引用。在普通的函数调用中，new.target 的值是 undefined。 也就是说 new.target 的功能就是用来检测函数的调用是不是通过 new 去创建一个新对象的，而且 new.target 返回的是一个指向函数的引用，也就是说我们能够确定是哪个函数进行了 new 操作。 ES6 的继承机制总结先创建父类实例 this 通过 class、 extends 、super 关键字定义子类，并改变 this 指向,super 本身是指向父类的构造函数但做函数调用后返回的是子类的实例，实际上做了父类.prototype.constructor.call(this)，做对象调用时指向父类.prototype,从而实现继承。]]></content>
      <categories>
        <category>面试题</category>
      </categories>
      <tags>
        <tag>面试题</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ES6面试题]]></title>
    <url>%2F2018%2F01%2F19%2FES6%2F</url>
    <content type="text"><![CDATA[ES6面试题 普通函数和箭头函数的区别 箭头函数没有 prototype(原型)，所以箭头函数本身没有 this 箭头函数的 this 在定义的时候继承自外层第一个普通函数的 this。 如果箭头函数外层没有普通函数，严格模式和非严格模式下它的 this 都会指向 window(全局对象) 箭头函数本身的 this 指向不能改变，但可以修改它要继承的对象的 this。 箭头函数的 this 指向全局，使用 arguments 会报未声明的错误。 箭头函数的 this 指向普通函数时,它的 argumens 继承于该普通函数 使用 new 调用箭头函数会报错，因为箭头函数没有 constructor 箭头函数不支持 new.target 箭头函数不支持重命名函数参数,普通函数的函数参数支持重命名 箭头函数相对于普通函数语法更简洁优雅 箭头函数的注意事项及不适用场景 箭头函数的注意事项： 箭头函数一条语句返回对象字面量，需要加括号 箭头函数在参数和箭头之间不能换行 箭头函数的解析顺序相对||靠前 不适用场景：箭头函数的 this 意外指向和代码的可读性。 Vue 的数据双向绑定原理]]></content>
      <categories>
        <category>面试题</category>
      </categories>
      <tags>
        <tag>面试题</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[hook学习]]></title>
    <url>%2F2018%2F01%2F19%2Fhook%2F</url>
    <content type="text"><![CDATA[hook学习]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>学习笔记</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[React的基本使用]]></title>
    <url>%2F2017%2F07%2F19%2FReact%E7%9A%84%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8%2F</url>
    <content type="text"><![CDATA[react 是什么 React 是一个 JS 库，用来构建用户界面（写 HTML，构建 web 应用） 从 MVC 的角度来看，相当于 视图层 V（View） 的内容。 react 的特点 声明式： 我们只需要描述页面长什么样子就可以了，React 负责更新页面 基于组件（组件化） 学习一次，随处使用（Web 、 安卓/ios、vr …） React 的基本使用 安装：npm i react react-dom 引入 react 和 react-dom 两个 js 文件（注意：引入顺序，react 在前，react-dom 在后） 创建 React 元素 const h1 = React.createElement(&#39;h1&#39;, null, &#39;子节点&#39;) 渲染创建好的 React 元素，到页面中 ReactDOM.render(h1, document.getElementById(&#39;root&#39;)) React.createElement() 方法的说明 作用：创建 react 元素的 12345678910111213141516171819202122// 创建React元素// 第一个参数：表示要创建什么元素，就是 HTML 标签名称// 第二个参数：表示元素自身属性，如果没有就传 null// 如果要指定元素自身的属性，就传递一个对象（&#123;&#125;）// 1 class ==&gt; className// 2 for ==&gt; htmlFor// 第三个及其以后的参数：表示元素的子节点（文本、元素节点）// 如果是文本节点，就直接传递 字符串。// 如果是元素节点，就继续调用 React.createElement() 方法，创建新的React元素节点//// const h1 = React.createElement('div', null, 'Hello React')const h1 = React.createElement( 'h1', &#123; id: 'title', className: 'cls', htmlFor: 'd' &#125;, 'Hello React', 'test 文本节点', React.createElement('span', null, '这是一个span')) React 脚手架初始化项目的步骤 命令：npx create-react-app 项目名称 比如：npx create-react-app my-app npx 命令：简化使用脚手架初始化项目的流程 不使用 npx：1 先全局安装脚手架的包 2 使用脚手架包提供的命令来初始化项目 使用 npx：不需要再全局安装脚手架的包，直接就可以初始化项目 如何启动项目？进入项目根目录然后，执行以下命令 yarn start npm start 在脚手架中使用 react 导入 import React from &#39;react&#39; import ReactDOM from &#39;react-dom&#39; JSX 为什么要学习 JSX ？ 因为 createElement 形式，太繁琐，不直观，书写效率不高，所以，我们不想用这种方式。 JSX 特点：不反锁，直观，书写效率高 JSX 是什么？ JavaScript XML（HTML），也就是在 JS 中书写 HTMl 格式的代码 JSX 的基本使用 导入 react 和 react-dom 使用 JSX 语法创建 React 元素 JSX 就跟写 HTML 一样 渲染创建好的 React 元素 JSX 语法的注意点 JSX 元素的属性名推荐使用：驼峰命名法 class ===&gt; className 如果元素没有子节点，可以使用 单标签 方式来结束 比如：&lt;div /&gt; 推荐使用 () 来包裹 JSX，从而避免 JS 中自动插入分号机制 在 JSX 中使用 JS 表达式（数据） 语法：使用 {} ，就可以在 JSX 中使用 JS 中的数据了 &lt;div&gt;Hello {name + &#39;666&#39;}&lt;/div&gt; 原则：可以在 {} 中使用任何的 JS 表达式。 注意：不能在 {} 中，使用 语句！ 比如： if/for/switch … 注意：不能在 {} 中使用对象，除了 style 属性以外！！！ JSX 自身也是一个 JS 表达式，所以，可以在 {} 中继续使用 JSX ！！！ React 的条件渲染 使用 if/esle 来实现 123456789const loadData = () =&gt; &#123; if (isLoading) &#123; return &lt;div&gt;loading...&lt;/div&gt; &#125; return &lt;div&gt;加载完成后的列表结构&lt;/div&gt;&#125;const h1 = &lt;div&gt;&#123;loadData()&#125;&lt;/div&gt; 使用三元表达式 123const loadData = () =&gt; &#123; return isLoading ? &lt;div&gt;loading...&lt;/div&gt; : &lt;div&gt;加载完成后的列表结构&lt;/div&gt;&#125; 逻辑运算符 &amp;&amp; 123const loadData = () =&gt; &#123; return isLoading &amp;&amp; &lt;div&gt;loading...&lt;/div&gt;&#125; React 中的列表渲染 使用数组的 map 方法来进行列表渲染 需要给被遍历生成的元素添加 key 属性，key 应该是唯一的。尽量避免使用 index 作为索引号。 剩下的就是 JS 中 map 方法的使用了。 12345&lt;ul&gt; &#123;songs.map(item =&gt; ( &lt;li key=&#123;item.id&#125;&gt;&#123;item.name&#125;&lt;/li&gt; ))&#125;&lt;/ul&gt; React 中给 JSX 添加样式 行内样式（style） 不推荐 12345const h1 = ( &lt;h1 style=&#123;&#123; color: 'red', fontSize: 30, backgroundColor: 'hotpink' &#125;&#125;&gt; 我变大了 &lt;/h1&gt;) className 类名 — 推荐！！！ 1const h1 = &lt;h1 className="pink"&gt;我变大了&lt;/h1&gt; 案例1234567;[ &#123; user: '张三', content: '哈哈，沙发' &#125;, &#123; user: '张三2', content: '哈哈，板凳' &#125;, &#123; user: '张三3', content: '哈哈，凉席' &#125;, &#123; user: '张三4', content: '哈哈，砖头' &#125;, &#123; user: '张三5', content: '哈哈，楼下山炮' &#125;]]]></content>
      <categories>
        <category>React</category>
      </categories>
      <tags>
        <tag>React</tag>
      </tags>
  </entry>
</search>
