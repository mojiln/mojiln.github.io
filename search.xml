<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[JS面试题]]></title>
    <url>%2F2019%2F07%2F25%2FJS%E9%9D%A2%E8%AF%95%E9%A2%98%2F</url>
    <content type="text"><![CDATA[根据日常总结的知识点进行分析 调用 new 的 4 件事 创建一个新对象 将对象里面的 this 指向这个新的对象 将新对象连接到构造函数的原型 返回这个对象 闭包函数 A 内部有一个函数 B，函数 B 可以访问带函数 A 中的变量，那么函数 B 就是闭包 私有变量 案例：沙箱]]></content>
      <categories>
        <category>面试题</category>
      </categories>
      <tags>
        <tag>面试题</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Vue面试题总结]]></title>
    <url>%2F2019%2F07%2F19%2F%E9%9D%A2%E8%AF%95%E9%A2%98%20-%20Vue%2F</url>
    <content type="text"><![CDATA[Vue面试题 v-if 和 v-show 区别v-show指令仅仅控制元素的显示方式，将display:none属性在 block 和 none 来回切换v-if指令会控制这个 DOM 节点的存在与否当我们需要经常切换某个元素的显示/隐藏时，使用 v-show 会更加节省性能;当只需要一次显示或隐藏时，使用 v-if Vue 的数据双向绑定原理采用数据劫持结合发布者-订阅者模式的方式，通过 Object.defineProperty()来劫持各个属性的 setter，getter,在数据变动时发布消息给订阅者，触发响应的监听回调。 Vue 组件间是怎么通讯的 常见指令 怎么定义组件 Vue 路由是怎么做的（路由的原理） 怎么请求数据 谈谈组件化和模块化的区别、模块化：是从代码逻辑的角度进行划分的，方便代码分层开发，保证每个功能模块的职能单一组件化：是从 UI 的角度进行划分的，前端的组件化，方便 UI 组件的复用 Vue 全家桶 Vuex 的使用和五个核心]]></content>
      <categories>
        <category>面试题</category>
      </categories>
      <tags>
        <tag>面试题</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[面试题总结]]></title>
    <url>%2F2019%2F07%2F19%2F%E9%9D%A2%E8%AF%95%E9%A2%98%2F</url>
    <content type="text"><![CDATA[根据日常总结的知识点进行分析 写 React / Vue 项目时为什么要在列表组件中写 key，其作用是什么解析：（Vue/React）key 的作用是为了在 diff 算法执行时更快的找到对应的节点，提高 diff 速度 (Vue)key 的作用是为了在数据变化时强制更新组件，以避免“原地复用”带来的副作用。 从用户刷新网页开始，一次 js 请求一般情况下有哪些地方会有缓存处理解析：DNS 缓存、CDN 缓存、浏览器缓存、服务器缓存 DNS 缓存 即 （Domain Name System 域名系统）为了增加访问效率， 计算机有域名缓存机制。即当访问过某个网站并得到其 IP 后，会将其域名和 IP 缓存下来， 下一次访问的时候，就不需要再请求域名服务器获取 IP, 直接使用缓存中的 IP，提高了响应的速度。 当前缓存时间是有有效时间的，当过了有效时间后， 还是需要先请求域名解析。 扩： DNS 预解析 因为在调用当前页面所在域名外的域名文件时，会遇到请求延时非常严重的情况。我们可以使用 DNS 预解析。 用 meta 信息来告知浏览器，当前页面要做 DNS 预解析： 1&lt;meta http-equiv="x-dns-prefetch-control" content="on" /&gt; 在页面 header 中使用 link 标签来强制对 DNS 预解析 1&lt;link rel="dns-prefetch" href="http://bdimg.share.baidu.com" /&gt; CDN 即 （Content Delivery NetWork） 内容分发网络CDN 是构建在网络之上的内容分发网络，依靠部署在各地的边缘服务器，通过中心平台的负载均衡、内容分发、调度等功能模块，使用户就近获取所需内容，降低网络拥塞，提高用户访问响应速度和命中率。CDN 的关键技术主要有内容存储和分发技术。 通俗解释：就是当我们发送一个 web 请求时，会先经过它一道手，然后它帮我们计算路径，去哪得到这些东东（representations）的路径短且快。这个是网站管理员部署的，所以他们也可以将大家经常访问的 representations 放在 CDN 里，这样，就响应就更快了。 浏览器缓存通过浏览器实现 HTTP 缓存。 Expires添加 Expires 头能有效的利用浏览器的缓存能力来改善页面的性能，能在后续的页面中有效避免很多不必要的 Http 请求，WEB 服务器使用 Expires 头来告诉 Web 客户端它可以使用一个组件的当前副本，直到指定的时间为止。 例如：Expires：Thu，15 Apr 2010 20：00：00 GMT; 他告诉浏览器缓存有效性持续到 2010 年 4 月 15 日为止，在这个时间之内相同的请求使用缓存，这个时间之外使用 http 请求。 Cathe-Control使用 max-age 指定组件被缓存多久，从请求开始在 max-age 时间内浏览器使用缓存，之外的使用请求，这样就可以消除 Expires 的限制. 例如：Cathe-Control：max-age=315360000 服务器缓存服务器缓存一般指缓存服务器缓存指的是将需要频繁访问的网络内容存放在离用户较近、访问速度更快的系统中，以提高内容访问速度的一种技术。缓存服务器就是存放频繁访问内容的服务器。 Javascript：history.go()和 history.back()的用法与区别go() 方法可加载历史列表中的某个具体的页面。该参数可以是数字，使用的是要访问的 URL 在 History 的 URL 列表中的相对位置。（-1 上一个页面，1 前进一个页面)。或一个字符串，字符串必须是局部或完整的 URL，该函数会去匹配字符串的第一个 URL。 go(-1):返回上一页，原页面表单中的内容会丢失；back():返回上一页，原页表表单中的内容会保留。 什么是防抖和节流？有什么区别？如何实现防抖(debounce)触发高频事件后 n 秒内函数只会执行一次，如果 n 秒内高频事件再次被触发，则重新计算时间(函数防抖: 任务频繁触发的情况下，只有任务触发的间隔超过指定间隔的时候，任务才会执行。) 思路：每次触发事件时都取消之前的延时调用方法 其实函数防抖的原理也非常地简单，通过闭包保存一个标记来保存 setTimeout 返回的值，每当用户输入的时候把前一个 setTimeout clear 掉，然后又创建一个新的 setTimeout，这样就能保证输入字符后的 interval 间隔内如果还有字符输入的话，就不会执行 fn 函数了。 12345678910111213141516function debounce(fn) &#123; let timeout = null // 创建一个标记用来存放定时器的返回值 return function() &#123; clearTimeout(timeout) // 每当用户输入的时候把前一个 setTimeout clear 掉 timeout = setTimeout(() =&gt; &#123; // 然后又创建一个新的 setTimeout, 这样就能保证输入字符后的 interval 间隔内如果还有字符输入的话，就不会执行 fn 函数 fn.apply(this, arguments) &#125;, 500) &#125;&#125;function sayHi() &#123; console.log('防抖成功')&#125;var inp = document.getElementById('inp')inp.addEventListener('input', debounce(sayHi)) // 防抖 节流(throttle)高频事件触发，但在 n 秒内只会执行一次，所以节流会稀释函数的执行频率(函数节流: 指定时间间隔内只会执行一次任务) 思路：每次触发事件时都判断当前是否有等待执行的延时函数 简单来说，函数的节流就是通过闭包保存一个标记（canRun = true），在函数的开头判断这个标记是否为 true，如果为 true 的话就继续执行函数，否则则 return 掉，判断完标记后立即把这个标记设为 false，然后把外部传入的函数的执行包在一个 setTimeout 中，最后在 setTimeout 执行完毕后再把标记设置为 true（这里很关键），表示可以执行下一次的循环了。当 setTimeout 还未执行的时候，canRun 这个标记始终为 false，在开头的判断中被 return 掉 1234567891011121314151617function throttle(fn) &#123; let canRun = true // 通过闭包保存一个标记 return function() &#123; if (!canRun) return // 在函数开头判断标记是否为true，不为true则return canRun = false // 立即设置为false setTimeout(() =&gt; &#123; // 将外部传入的函数的执行放在setTimeout中 fn.apply(this, arguments) // 最后在setTimeout执行完毕后再把标记设置为true(关键)表示可以执行下一次循环了。当定时器没有执行的时候标记永远是false，在开头被return掉 canRun = true &#125;, 500) &#125;&#125;function sayHi(e) &#123; console.log(e.target.innerWidth, e.target.innerHeight)&#125;window.addEventListener('resize', throttle(sayHi)) 总结：其实函数节流与函数防抖的原理非常简单，巧妙地使用 setTimeout 来存放待执行的函数，这样可以很方便的利用 clearTimeout 在合适的时机来清除待执行的函数。使用函数节流与函数防抖的目的，在开头的栗子中应该也能看得出来，就是为了节约计算机资源。]]></content>
      <categories>
        <category>面试题</category>
      </categories>
      <tags>
        <tag>面试题</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hello World]]></title>
    <url>%2F2019%2F07%2F16%2Fhello-world%2F</url>
    <content type="text"><![CDATA[Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new "My New Post" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment]]></content>
  </entry>
  <entry>
    <title><![CDATA[js 的继承机制]]></title>
    <url>%2F2019%2F01%2F19%2Fjs%E7%BB%A7%E6%89%BF%E6%9C%BA%E5%88%B6%2F</url>
    <content type="text"><![CDATA[js 的继承机制 ES5 和 ES6 及继承机制这几天在学习 react 的时候学习到 ES6 的 class extends 继承方式，就复习一下 ES5 的继承机制，并整理下来。 ES5 继承机制在 js 万物皆对象，但事还是区分普通对象和函数对象，那大家需要知道是只有函数对象才有 prototype 属性，但所有对象都有__proto__属性 12function A() &#123;&#125;var B = new A() 那这里就得出几个公式： 123B.**proto**== A.prototype;B.constructor == A;a.prototype.constuctor = A; 那这是实现继承的基础； 也就是说 A.prototype 是 A 的原型对象，A 是构造函数，B 是 A 的实例，原型对象（A.prototype）是 构造函数（A）的一个实例。而此时 this 指向是指向实例。 明白这个关系实现继承就很简单了！看一下下面的代码 原型链继承通过重写子类的原型 等于 父类的一个实例，（父类的实例属相变成子类的原型属性） 1234567891011121314function father() &#123; this.faName = 'father'&#125;father.prototype.getfaName = function() &#123; console.log(this.faName)&#125;function child() &#123; this.chName = 'child'&#125;child.prototype = new father()child.prototype.constructor = childchild.prototype.getchName = function() &#123; console.log(this.chName)&#125; 组合继承 （比较常用，也有缺点）通过子类的原型对象指向父类实例的方式来实现继承，那我们不难发现原型链的形成是真正是靠__proto__ 而非 prototype，子类的实例可以访问父类原型上的方法，是因为子类实例通过__proto__与父类的原型对象有连接 1234567891011121314151617181920//先来个父类，带些属性function Super() &#123; this.flag = true&#125;//为了提高复用性，方法绑定在父类原型属性上Super.prototype.getFlag = function() &#123; return this.flag&#125;//来个子类function Sub() &#123; this.subFlag = false&#125;//实现继承Sub.prototype = new Super()//给子类添加子类特有的方法，注意顺序要在继承之后Sub.prototype.getSubFlag = function() &#123; return this.subFlag&#125;//构造实例var es5 = new Sub() 寄生组合继承 （业内比较提倡的方法）所谓寄生组合式继承，即通过借助构造函数来继承属性，通过原型链的混成形式来继承方法。 其背后的基本思路是：不必为了指定子类型的原型而调用超类型的构造函数，我们所需要的无非就是超类型原型的一个副本而已。本质上，就是使用寄生式继承来继承超类型的原型，然后再将结果指定给子类型的原型。 12345678910111213141516171819202122232425function inserit(son, father) &#123; var obj = Object.create(father.prototype) son.prototype = obj obj.constructor = son&#125;function SuperType(name, colors) &#123; this.name = name this.colors = colors&#125;SuperType.prototype.sayName = function() &#123; return this.name&#125;function SubType(job, name, color) &#123; SuperType.call(this, name, color) this.job = job&#125;//核心方法inserit(SubType, SuperType)SubType.prototype.sayjob = function() &#123; return this.job&#125;var instance = new SubType('doctor', 'John', ['red', 'green'])console.log(instance.sayjob(), instance.sayName()) //doctor,John [x] 原型链继承缺点：父类包含引用类型的属性，那么子类所有实例都会共享该属性（包含引用类型的原型属性会被实例共享），在创建子类实例时，不能向父类的构造函数传递参数[x] 组合继承的缺点：两次调用父类构造函数：（第一次是在创建子类原型的时候，第二次是在子类构造函数内部）子类继承父类的属性，一组在子类实例上，一组在子类原型上（在子类原型上创建不必要的多余的属性）（实例上的屏蔽原型上的同名属性）效率低[x] 组合继承的优点：只调用一次父类的构造函数,避免了在子类原型上创建不必要的，多余的属性，原型链保持不变ES5 的继承机制总结ES5 的继承机制简单来说就是：实质是先创造子类的实例对象 this，然后再将父类的方法添加到 this 上面（Parent.apply(this)） ES6 的继承机制1234567891011121314151617181920class Point &#123; constructor(x) &#123; this.x = 1 this.p = 2 &#125; print() &#123; return this.x &#125;&#125;Point.prototype.z = '4'class ColorPoint extends Point &#123; constructor(x) &#123; this.color = color // ReferenceError super(x, y) this.x = x // 正确 &#125; m() &#123; super.print() &#125;&#125; ES6 继承是通过 class、extends 关键字来实现继承 Point 是父类，ColorPoint 是子类 通过 class 新建子类 extends 继承父类的方式实现继承，方式比 ES5 简单的多。 constructorconstructor 方法是类的构造函数，是一个默认方法，通过 new 命令创建对象实例时，自动调用该方法。一个类必须有 constructor 方法，如果没有显式定义，一个默认的 consructor 方法会被默认添加。所以即使你没有添加构造函数，也是会有一个默认的构造函数的。一般 constructor 方法返回实例对象 this ，但是也可以指定 constructor 方法返回一个全新的对象，让返回的实例对象不是该类的实例。 1234567891011121314151617181920class Points &#123;constructor(x) &#123;this.x = 1;this.p = 2;&#125;print() &#123;return this.x;&#125;statc getname()&#123;return new.target.name;&#125;&#125;// 等同于：function Points(x) &#123;this.x = x;this.p = 2;&#125;Points.prototype.print = function() &#123;return '(' + this.x +')';&#125; 也就是说 constructor 就代表在父类上加属性，而在 class 对象加方法属性 等于在原型上的加。而这些属性方法 只有通过 new 出的实例 或者是 extends 继承出来的实例才可以获取到 所以我们可以得到 12new Points().__proto__.print() //可以调用到 Points 的 print 方法new Points().x = 1 //可以调用到 constructor 里面的 this.x=1 supersuper 既可以当做函数使用，也可以当做对象使用两种使用的时候完全不一样， 函数用时 : 在 constructor 中必须调用 super 方法，因为子类没有自己的 this 对象，而是继承父类的 this 对象，然后对其进行加工,而 super 就代表了父类的构造函数。super 虽然代表了父类 A 的构造函数，但是返回的是子类 B 的实例，即 super 内部的 this 指的是 B，因此 super() 在这里相当于 1A.prototype.constructor.call(this, props) 在 super() 执行时，它指向的是 子类 B 的构造函数，而不是父类 A 的构造函数。也就是说，super() 内部的 this 指向的是 B。所以在第一个 es6 的例子中子类的 this 指向的是自己。、 当做对象使用 ： 在普通方法中，指向父类的原型对象；在静态方法中，指向父类。 所以在子类的方法中 super.print();指向的是父类原型上的方法。 但是因为 super 的两种用法，所以 es6 规定在使用必须要明确使用方式，像单独 console.log(super) 就会报错。 static顾名思义是静态方法的意思，类相当于实例的原型， 所有在类中定义的方法， 都会被实例继承。 如果在一个方法前， 加上 static 关键字， 就表示该方法不会被实例继承， 而是直接通过类来调用， 这就称为“ 静态方法”。静态方法调用直接在类上进行，而在类的实例上不可被调用。静态方法通常用于创建 实用/工具 函数。 new.targetnew.target 属性允许你检测函数或构造方法是否通过是通过 new 运算符被调用的。在通过 new 运算符被初始化的函数或构造方法中，new.target 返回一个指向构造方法或函数的引用。在普通的函数调用中，new.target 的值是 undefined。 也就是说 new.target 的功能就是用来检测函数的调用是不是通过 new 去创建一个新对象的，而且 new.target 返回的是一个指向函数的引用，也就是说我们能够确定是哪个函数进行了 new 操作。 ES6 的继承机制总结先创建父类实例 this 通过 class、 extends 、super 关键字定义子类，并改变 this 指向,super 本身是指向父类的构造函数但做函数调用后返回的是子类的实例，实际上做了父类.prototype.constructor.call(this)，做对象调用时指向父类.prototype,从而实现继承。]]></content>
      <categories>
        <category>面试题</category>
      </categories>
      <tags>
        <tag>面试题</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[React的基本使用]]></title>
    <url>%2F2018%2F07%2F19%2FReact%E7%9A%84%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8%2F</url>
    <content type="text"><![CDATA[react 是什么 React 是一个 JS 库，用来构建用户界面（写 HTML，构建 web 应用） 从 MVC 的角度来看，相当于 视图层 V（View） 的内容。 react 的特点 声明式： 我们只需要描述页面长什么样子就可以了，React 负责更新页面 基于组件（组件化） 学习一次，随处使用（Web 、 安卓/ios、vr …） React 的基本使用 安装：npm i react react-dom 引入 react 和 react-dom 两个 js 文件（注意：引入顺序，react 在前，react-dom 在后） 创建 React 元素 const h1 = React.createElement(&#39;h1&#39;, null, &#39;子节点&#39;) 渲染创建好的 React 元素，到页面中 ReactDOM.render(h1, document.getElementById(&#39;root&#39;)) React.createElement() 方法的说明 作用：创建 react 元素的 12345678910111213141516171819202122// 创建React元素// 第一个参数：表示要创建什么元素，就是 HTML 标签名称// 第二个参数：表示元素自身属性，如果没有就传 null// 如果要指定元素自身的属性，就传递一个对象（&#123;&#125;）// 1 class ==&gt; className// 2 for ==&gt; htmlFor// 第三个及其以后的参数：表示元素的子节点（文本、元素节点）// 如果是文本节点，就直接传递 字符串。// 如果是元素节点，就继续调用 React.createElement() 方法，创建新的React元素节点//// const h1 = React.createElement('div', null, 'Hello React')const h1 = React.createElement( 'h1', &#123; id: 'title', className: 'cls', htmlFor: 'd' &#125;, 'Hello React', 'test 文本节点', React.createElement('span', null, '这是一个span')) React 脚手架初始化项目的步骤 命令：npx create-react-app 项目名称 比如：npx create-react-app my-app npx 命令：简化使用脚手架初始化项目的流程 不使用 npx：1 先全局安装脚手架的包 2 使用脚手架包提供的命令来初始化项目 使用 npx：不需要再全局安装脚手架的包，直接就可以初始化项目 如何启动项目？进入项目根目录然后，执行以下命令 yarn start npm start 在脚手架中使用 react 导入 import React from &#39;react&#39; import ReactDOM from &#39;react-dom&#39; JSX 为什么要学习 JSX ？ 因为 createElement 形式，太繁琐，不直观，书写效率不高，所以，我们不想用这种方式。 JSX 特点：不反锁，直观，书写效率高 JSX 是什么？ JavaScript XML（HTML），也就是在 JS 中书写 HTMl 格式的代码 JSX 的基本使用 导入 react 和 react-dom 使用 JSX 语法创建 React 元素 JSX 就跟写 HTML 一样 渲染创建好的 React 元素 JSX 语法的注意点 JSX 元素的属性名推荐使用：驼峰命名法 class ===&gt; className 如果元素没有子节点，可以使用 单标签 方式来结束 比如：&lt;div /&gt; 推荐使用 () 来包裹 JSX，从而避免 JS 中自动插入分号机制 在 JSX 中使用 JS 表达式（数据） 语法：使用 {} ，就可以在 JSX 中使用 JS 中的数据了 &lt;div&gt;Hello {name + &#39;666&#39;}&lt;/div&gt; 原则：可以在 {} 中使用任何的 JS 表达式。 注意：不能在 {} 中，使用 语句！ 比如： if/for/switch … 注意：不能在 {} 中使用对象，除了 style 属性以外！！！ JSX 自身也是一个 JS 表达式，所以，可以在 {} 中继续使用 JSX ！！！ React 的条件渲染 使用 if/esle 来实现 123456789const loadData = () =&gt; &#123; if (isLoading) &#123; return &lt;div&gt;loading...&lt;/div&gt; &#125; return &lt;div&gt;加载完成后的列表结构&lt;/div&gt;&#125;const h1 = &lt;div&gt;&#123;loadData()&#125;&lt;/div&gt; 使用三元表达式 123const loadData = () =&gt; &#123; return isLoading ? &lt;div&gt;loading...&lt;/div&gt; : &lt;div&gt;加载完成后的列表结构&lt;/div&gt;&#125; 逻辑运算符 &amp;&amp; 123const loadData = () =&gt; &#123; return isLoading &amp;&amp; &lt;div&gt;loading...&lt;/div&gt;&#125; React 中的列表渲染 使用数组的 map 方法来进行列表渲染 需要给被遍历生成的元素添加 key 属性，key 应该是唯一的。尽量避免使用 index 作为索引号。 剩下的就是 JS 中 map 方法的使用了。 12345&lt;ul&gt; &#123;songs.map(item =&gt; ( &lt;li key=&#123;item.id&#125;&gt;&#123;item.name&#125;&lt;/li&gt; ))&#125;&lt;/ul&gt; React 中给 JSX 添加样式 行内样式（style） 不推荐 12345const h1 = ( &lt;h1 style=&#123;&#123; color: 'red', fontSize: 30, backgroundColor: 'hotpink' &#125;&#125;&gt; 我变大了 &lt;/h1&gt;) className 类名 — 推荐！！！ 1const h1 = &lt;h1 className="pink"&gt;我变大了&lt;/h1&gt; 案例1234567;[ &#123; user: '张三', content: '哈哈，沙发' &#125;, &#123; user: '张三2', content: '哈哈，板凳' &#125;, &#123; user: '张三3', content: '哈哈，凉席' &#125;, &#123; user: '张三4', content: '哈哈，砖头' &#125;, &#123; user: '张三5', content: '哈哈，楼下山炮' &#125;]]]></content>
      <categories>
        <category>React</category>
      </categories>
      <tags>
        <tag>React</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ES6面试题]]></title>
    <url>%2F2018%2F01%2F19%2FES6%2F</url>
    <content type="text"><![CDATA[ES6面试题 普通函数和箭头函数的区别 箭头函数没有 prototype(原型)，所以箭头函数本身没有 this 箭头函数的 this 在定义的时候继承自外层第一个普通函数的 this。 如果箭头函数外层没有普通函数，严格模式和非严格模式下它的 this 都会指向 window(全局对象) 箭头函数本身的 this 指向不能改变，但可以修改它要继承的对象的 this。 箭头函数的 this 指向全局，使用 arguments 会报未声明的错误。 箭头函数的 this 指向普通函数时,它的 argumens 继承于该普通函数 使用 new 调用箭头函数会报错，因为箭头函数没有 constructor 箭头函数不支持 new.target 箭头函数不支持重命名函数参数,普通函数的函数参数支持重命名 箭头函数相对于普通函数语法更简洁优雅 箭头函数的注意事项及不适用场景 箭头函数的注意事项： 箭头函数一条语句返回对象字面量，需要加括号 箭头函数在参数和箭头之间不能换行 箭头函数的解析顺序相对||靠前 不适用场景：箭头函数的 this 意外指向和代码的可读性。 Vue 的数据双向绑定原理]]></content>
      <categories>
        <category>面试题</category>
      </categories>
      <tags>
        <tag>面试题</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Set、Map、WeakSet 和 WeakMap 的区别]]></title>
    <url>%2F2018%2F01%2F19%2FES6%20copy%2F</url>
    <content type="text"><![CDATA[Set、Map、WeakSet 和 WeakMap 的区别 介绍下 Set、Map、WeakSet 和 WeakMap 的区别Set 和 Map 主要的应用场景在于 数据重组 和 数据储存 Set 是一种叫做集合的数据结构，Map 是一种叫做字典的数据结构 集合（Set）ES6 新增的一种新的数据结构，类似于数组，但成员是唯一且无序的，没有重复的值。 Set 本身是一种构造函数，用来生成 Set 数据结构。 new Set([iterable])举个例子： 12345678const s = new Set()[1, 2, 3, 4, 3, 2, 1].forEach(x =&gt; s.add(x))for (let i of s) &#123; console.log(i) // 1 2 3 4&#125; // 去重数组的重复对象let arr = [1, 2, 3, 2, 1, 1][... new Set(arr)] // [1, 2, 3] Set 对象允许你储存任何类型的唯一值，无论是原始值或者是对象引用。 向 Set 加入值的时候，不会发生类型转换，所以 5 和”5”是两个不同的值。Set 内部判断两个值是否不同，使用的算法叫做“Same-value-zero equality”，它类似于精确相等运算符（===），主要的区别是NaN 等于自身，而精确相等运算符认为 NaN 不等于自身。 1234567891011let set = new Set()let a = NaNlet b = NaNset.add(a)set.add(b)set // Set &#123;NaN&#125;let set1 = new Set()set1.add(5)set1.add('5')console.log([...set1]) // [5, "5"] Set 实例属性 constructor： 构造函数 size：元素数量 1234let set = new Set([1, 2, 3, 2, 1])console.log(set.length) // undefinedconsole.log(set.size) // 3 Set 实例方法 操作方法add(value)：新增，相当于 array 里的 push delete(value)：存在即删除集合中 value has(value)：判断集合中是否存在 value clear()：清空集合 12345678910let set = new Set()set .add(1) .add(2) .add(1)set.has(1) // trueset.has(3) // falseset.delete(1)set.has(1) // false Array.from 方法可以将 Set 结构转为数组 123456const items = new Set([1, 2, 3, 2])const array = Array.from(items)console.log(array) // [1, 2, 3]// 或const arr = [...items]console.log(arr) // [1, 2, 3] 遍历方法（遍历顺序为插入顺序）keys()：返回一个包含集合中所有键的迭代器 values()：返回一个包含集合中所有值得迭代器 entries()：返回一个包含 Set 对象中所有元素得键值对迭代器 forEach(callbackFn, thisArg)：用于对集合成员执行 callbackFn 操作，如果提供了 thisArg 参数，回调中的 this 会是这个参数，没有返回值 12345678910111213141516let set = new Set([1, 2, 3])console.log(set.keys()) // SetIterator &#123;1, 2, 3&#125;console.log(set.values()) // SetIterator &#123;1, 2, 3&#125;console.log(set.entries()) // SetIterator &#123;1, 2, 3&#125;for (let item of set.keys()) &#123; console.log(item)&#125; // 1 2 3for (let item of set.entries()) &#123; console.log(item)&#125; // [1, 1][2, 2] [3, 3]set.forEach((value, key) =&gt; &#123; console.log(key + ' : ' + value)&#125;) // 1 : 1 2 : 2 3 : 3console.log([...set]) // [1, 2, 3] Set 可默认遍历，默认迭代器生成函数是 values() 方法 1Set.prototype[Symbol.iterator] === Set.prototype.values // true 所以， Set 可以使用 map、filter 方法 123456let set = new Set([1, 2, 3])set = new Set([...set].map(item =&gt; item \* 2))console.log([...set]) // [2, 4, 6]set = new Set([...set].filter(item =&gt; (item &gt;= 4)))console.log([...set]) //[4, 6] 因此，Set 很容易实现交集（Intersect）、并集（Union）、差集（Difference） 12345678910let set1 = new Set([1, 2, 3])let set2 = new Set([4, 3, 2])let intersect = new Set([...set1].filter(value =&gt; set2.has(value)))let union = new Set([...set1, ...set2])let difference = new Set([...set1].filter(value =&gt; !set2.has(value)))console.log(intersect) // Set &#123;2, 3&#125;console.log(union) // Set &#123;1, 2, 3, 4&#125;console.log(difference) // Set &#123;1&#125; WeakSetWeakSet 对象允许你将弱引用对象储存在一个集合中 WeakSet 与 Set 的区别： WeakSet 只能储存对象引用，不能存放值，而 Set 对象都可以WeakSet 对象中储存的对象值都是被弱引用的，即垃圾回收机制不考虑 WeakSet 对该对象的应用，如果没有其他的变量或属性引用这个对象值，则这个对象将会被垃圾回收掉（不考虑该对象还存在于 WeakSet 中），所以，WeakSet 对象里有多少个成员元素，取决于垃圾回收机制有没有运行，运行前后成员个数可能不一致，遍历结束之后，有的成员可能取不到了（被垃圾回收了），WeakSet 对象是无法被遍历的（ES6 规定 WeakSet 不可遍历），也没有办法拿到它包含的所有元素属性： constructor：构造函数，任何一个具有 Iterable 接口的对象，都可以作参数 123const arr = [[1, 2], [3, 4]]const weakset = new WeakSet(arr)console.log(weakset) 方法： add(value)：在 WeakSet 对象中添加一个元素 valuehas(value)：判断 WeakSet 对象中是否包含 valuedelete(value)：删除元素 valueclear()：清空所有元素，注意该方法已废弃 123456789101112var ws = new WeakSet()var obj = &#123;&#125;var foo = &#123;&#125;ws.add(window)ws.add(obj)ws.has(window) // truews.has(foo) // falsews.delete(window) // truews.has(window) // false 字典（Map）集合 与 字典 的区别：共同点：集合、字典 可以储存不重复的值不同点：集合 是以 [value, value]的形式储存元素，字典 是以 [key, value] 的形式储存 12345678const m = new Map()const o = &#123; p: 'haha' &#125;m.set(o, 'content')m.get(o) // contentm.has(o) // truem.delete(o) // truem.has(o) // false 任何具有 Iterator 接口、且每个成员都是一个双元素的数组的数据结构都可以当作 Map 构造函数的参数，例如： 1234567const set = new Set([['foo', 1], ['bar', 2]])const m1 = new Map(set)m1.get('foo') // 1const m2 = new Map([['baz', 3]])const m3 = new Map(m2)m3.get('baz') // 3 如果读取一个未知的键，则返回 undefined。 12new Map().get('asfddfsasadf')// undefined 注意，只有对同一个对象的引用，Map 结构才将其视为同一个键。这一点要非常小心。 1234const map = new Map()map.set(['a'], 555)map.get(['a']) // undefined 上面代码的 set 和 get 方法，表面是针对同一个键，但实际上这是两个值，内存地址是不一样的，因此 get 方法无法读取该键，返回 undefined。 由上可知，Map 的键实际上是跟内存地址绑定的，只要内存地址不一样，就视为两个键。这就解决了同名属性碰撞（clash）的问题，我们扩展别人的库的时候，如果使用对象作为键名，就不用担心自己的属性与原作者的属性同名。 如果 Map 的键是一个简单类型的值（数字、字符串、布尔值），则只要两个值严格相等，Map 将其视为一个键，比如 0 和-0 就是一个键，布尔值 true 和字符串 true 则是两个不同的键。另外，undefined 和 null 也是两个不同的键。虽然 NaN 不严格相等于自身，但 Map 将其视为同一个键。 123456789101112131415let map = new Map()map.set(-0, 123)map.get(+0) // 123map.set(true, 1)map.set('true', 2)map.get(true) // 1map.set(undefined, 3)map.set(null, 4)map.get(undefined) // 3map.set(NaN, 123)map.get(NaN) // 123 Map 的属性及方法 属性： constructor：构造函数 size：返回字典中所包含的元素个数 123const map = new Map([['name', 'An'], ['des', 'JS']])map.size // 2 操作方法： set(key, value)：向字典中添加新元素get(key)：通过键查找特定的数值并返回has(key)：判断字典中是否存在键 keydelete(key)：通过键 key 从字典中移除对应的数据clear()：将这个字典中的所有元素删除遍历方法 Keys()：将字典中包含的所有键名以迭代器形式返回values()：将字典中包含的所有数值以迭代器形式返回entries()：返回所有成员的迭代器forEach()：遍历字典的所有成员 123const map = new Map([['name', 'An'], ['des', 'JS']])console.log(map.entries()) // MapIterator &#123;"name" =&gt; "An", "des" =&gt; "JS"&#125;console.log(map.keys()) // MapIterator &#123;"name", "des"&#125; Map 结构的默认遍历器接口（Symbol.iterator 属性），就是 entries 方法。 12map[Symbol.iterator] === map.entries// true Map 结构转为数组结构，比较快速的方法是使用扩展运算符（…）。 对于 forEach ，看一个例子 123456789101112const reporter = &#123; report: function(key, value) &#123; console.log('Key: %s, Value: %s', key, value) &#125;&#125;let map = new Map([['name', 'An'], ['des', 'JS']])map.forEach(function(value, key, map) &#123; this.report(key, value)&#125;, reporter)// Key: name, Value: An// Key: des, Value: JS 在这个例子中， forEach 方法的回调函数的 this，就指向 reporter 与其他数据结构的相互转换 Map 转 Array 12const map = new Map([[1, 1], [2, 2], [3, 3]])console.log([...map]) // [[1, 1], [2, 2], [3, 3]] Array 转 Map 12const map = new Map([[1, 1], [2, 2], [3, 3]])console.log(map) // Map &#123;1 =&gt; 1, 2 =&gt; 2, 3 =&gt; 3&#125; Map 转 Object 因为 Object 的键名都为字符串，而 Map 的键名为对象，所以转换的时候会把非字符串键名转换为字符串键名。 123456789function mapToObj(map) &#123; let obj = Object.create(null) for (let [key, value] of map) &#123; obj[key] = value &#125; return obj&#125;const map = new Map().set('name', 'An').set('des', 'JS')mapToObj(map) // &#123;name: "An", des: "JS"&#125; Object 转 Map 123456789function objToMap(obj) &#123; let map = new Map() for (let key of Object.keys(obj)) &#123; map.set(key, obj[key]) &#125; return map&#125;objToMap(&#123; name: 'An', des: 'JS' &#125;) // Map &#123;"name" =&gt; "An", "des" =&gt; "JS"&#125; Map 转 JSON 123456function mapToJson(map) &#123; return JSON.stringify([...map])&#125;let map = new Map().set('name', 'An').set('des', 'JS')mapToJson(map) // [["name","An"],["des","JS"]] JSON 转 Map 12345function jsonToStrMap(jsonStr) &#123; return objToMap(JSON.parse(jsonStr))&#125;jsonToStrMap('&#123;"name": "An", "des": "JS"&#125;') // Map &#123;"name" =&gt; "An", "des" =&gt; "JS"&#125; WeakMapWeakMap 对象是一组键值对的集合，其中的键是弱引用对象，而值可以是任意。 注意，WeakMap 弱引用的只是键名，而不是键值。键值依然是正常引用。 WeakMap 中，每个键对自己所引用对象的引用都是弱引用，在没有其他引用和该键引用同一对象，这个对象将会被垃圾回收（相应的 key 则变成无效的），所以，WeakMap 的 key 是不可枚举的。 属性： constructor：构造函数方法： has(key)：判断是否有 key 关联对象get(key)：返回 key 关联对象（没有则则返回 undefined）set(key)：设置一组 key 关联对象delete(key)：移除 key 的关联对象 12345678910111213let myElement = document.getElementById('logo')let myWeakmap = new WeakMap()myWeakmap.set(myElement, &#123; timesClicked: 0 &#125;)myElement.addEventListener( 'click', function() &#123; let logoData = myWeakmap.get(myElement) logoData.timesClicked++ &#125;, false) 总结Set成员唯一、无序且不重复[value, value]，键值与键名是一致的（或者说只有键值，没有键名）可以遍历，方法有：add、delete、hasWeakSet成员都是对象成员都是弱引用，可以被垃圾回收机制回收，可以用来保存 DOM 节点，不容易造成内存泄漏不能遍历，方法有 add、delete、hasMap本质上是键值对的集合，类似集合可以遍历，方法很多可以跟各种数据格式转换WeakMap只接受对象作为键名（null 除外），不接受其他类型的值作为键名键名是弱引用，键值可以是任意的，键名所指向的对象可以被垃圾回收，此时键名是无效的不能遍历，方法有 get、set、has、delete 扩展：Object 与 Set、MapObject 与 Set 123456789101112// Objectconst properties1 = &#123; width: 1, height: 1&#125;console.log(properties1['width'] ? true : false) // true// Setconst properties2 = new Set()properties2.add('width')properties2.add('height')console.log(properties2.has('width')) // true Object 与 Map JS 中的对象（Object），本质上是键值对的集合（hash 结构） 12345const data = &#123;&#125;const element = document.getElementsByClassName('App')data[element] = 'metadata'console.log(data['[object HTMLCollection]']) // "metadata" 但当以一个 DOM 节点作为对象 data 的键，对象会被自动转化为字符串[Object HTMLCollection]，所以说，Object 结构提供了 字符串-值 对应，Map 则提供了 值-值的对应 Vue 的数据双向绑定原理]]></content>
      <categories>
        <category>面试题</category>
      </categories>
      <tags>
        <tag>面试题</tag>
      </tags>
  </entry>
</search>
